{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quarkus OpenShift + OpenShift AI Workshop","text":"<p>Welcome to the Quarkus OpenShift Workshop! This workshop is designed to help you get started with Quarkus and OpenShift and OpenShift.ai. You are going to learn about:</p> <ul> <li>Red Hat Developer Hub - the developer portal to initiate and maintain application development</li> <li>Quarkus - the Kubernetes Native Java stack tailored for Kubernetes and OpenShift</li> <li>Red Hat OpenShift - the Kubernetes platform for enterprise applications</li> <li>Red Hat Trusted Application Pipelines - the CI/CD pipeline enhancing security with automatic, integrated checks that catch vulnerabilities early in the software supply chain.</li> <li>Red Hat OpenShift AI - the AI/ML platform for OpenShift</li> </ul>"},{"location":"#the-system","title":"The system","text":"<p>In this workshop, we will be working on a very simple system composed of four services:</p> <ul> <li>a <code>hero service</code> - a simple REST service that returns superheroes. It uses a <code>PostgreSQL</code> database to store the heroes.</li> <li>a <code>villain service</code> - the <code>hero service</code> alter-ego storing super villains . It uses a <code>PostgreSQL</code> database to store the villains.</li> <li>a <code>fight service</code> - a service that orchestrates the fight between heroes and villains. It relies on AI to predict the outcome of the fight and generate a narration of the fight.</li> <li>a <code>fight ui</code> - a simple UI to interact with the <code>fight service</code>. This service is provided and already deployed in the OpenShift cluster.</li> </ul>"},{"location":"#the-development","title":"The development","text":"<p>All the development is done in codespaces, so you only need a recent web browser.  There is no need to install anything on your machine!</p> <p>You will get access to an OpenShift cluster where you will deploy the services that you will develop.</p>"},{"location":"#lets-get-started","title":"Let\u2019s get started!","text":"<p>Go to the overview page to start the workshop.</p>"},{"location":"conclusion-references/","title":"Conclusion","text":""},{"location":"conclusion-references/#references","title":"References","text":""},{"location":"containers-cloud/","title":"From Git to OpenShift","text":""},{"location":"containers-cloud/#build-and-deploy","title":"Build and deploy","text":"<p>Build and deploy (in a single step)</p>"},{"location":"containers-cloud/#deploying-others","title":"Deploying others","text":"<p>Deploying the others microservices</p>"},{"location":"fight-microservice/","title":"Intelligent Fight microservice","text":""},{"location":"fight-microservice/#overview-of-llm-integration-in-quarkus","title":"Overview of LLM Integration in Quarkus","text":""},{"location":"fight-microservice/#using-quarkus-langchain4j-extension","title":"Using Quarkus-LangChain4j Extension","text":""},{"location":"fight-microservice/#code-implementation","title":"Code implementation","text":""},{"location":"fight-microservice/#adding-the-quarkus-langchain4j-xxxxx-extension","title":"Adding the quarkus-langchain4j-xxxxx extension","text":""},{"location":"fight-microservice/#defining-llm-interactions-with-registeraiservice","title":"Defining LLM interactions with @RegisterAiService","text":""},{"location":"fight-microservice/#running-testing-and-packaging","title":"Running, testing and packaging","text":""},{"location":"fight-microservice/#custom-metrics","title":"Custom metrics","text":""},{"location":"hero-microservice/","title":"Creating the Hero Microservice","text":"<p>In the following sections, you will learn:</p> <ul> <li>how to create a new Quarkus application using Red Hat Developer Hub, and</li> <li>how to implement REST API using JAX-RS, and</li> <li>how to compose your application using CDI beans, and</li> <li>how to access your database using Hibernate with Panache, and</li> <li>how to use transactions, and</li> </ul>"},{"location":"hero-microservice/#bootstrapping-the-hero-rest-endpoint","title":"Bootstrapping the Hero Rest Endpoint","text":""},{"location":"hero-microservice/#red-hat-developer-hub-software-templates-and-dev-spaces-workspace","title":"Red Hat Developer Hub Software templates and Dev Spaces workspace.","text":"<p>To create a Dev Spaces (DS) workspace, you\u2019ll first need to create a Software Component using a Red Hat Developer Hub (RHDH) Software Template:</p> <ol> <li>Navigate to the Create Option: in the left-hand menu of the RHDH, click on the \u201cCreate\u201d option.</li> <li>Select the template: you\u2019ll see a list of available templates. Choose the <code>OpenCodeQuest - Quarkus with Postgresql</code> template from the list.</li> <li>Configure the workspace: after selecting the template, you\u2019ll need to provide the necessary values for clusters and other configurations. Most of these fields will be pre-filled by default, so you may only need to make minor adjustments if necessary.</li> <li>Proceed with the setup: Once you\u2019ve reviewed the configurations, proceed to create your DS workspace.</li> </ol> <p>Once created, the component is available in the catalog. You can access it to have an overview:</p> <p></p> <p>Launch the Dev Spaces creation by clicking the link OpenShift Dev Spaces (VS Code).</p>"},{"location":"hero-microservice/#the-hero-service","title":"The Hero Service","text":"<p>At the heart of the Super Hero application come heroes.</p> <p>We need to expose a REST API allowing CRUD operations on super heroes. This microservice is, let\u2019s say, a classical microservice. It uses HTTP to expose a REST API, and it internally stores data into a database.</p> <p>This service will be used by the fight microservice.</p> <p></p> <p>First, let\u2019s describe our service. The Super Heroes microservice stores super-heroes, with their names, powers, and so on. The REST API allows adding, removing, listing, and picking a random hero from the stored set.</p> <p>Nothing outstanding but a good first step to discover Quarkus.</p>"},{"location":"hero-microservice/#directory-structure","title":"Directory Structure","text":"<p>Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:</p> <p></p> <p>It generates the following in the <code>hero-service</code> folder:</p> <ul> <li>the Maven structure with a <code>pom.xml</code></li> <li>an <code>io.quarkus.workshop.hero.HeroResource</code> resource exposed on <code>/api/heroes</code></li> <li>an associated unit test <code>HeroResourceTest</code></li> <li>the landing page <code>index.html</code> that is accessible after starting the application</li> <li>example <code>Dockerfile</code> files for both native and jvm modes in <code>src/main/docker</code></li> <li>the <code>application.properties</code> configuration file</li> </ul> <p>Once generated, look at the <code>pom.xml</code>. You will find the here import of the Quarkus BOM (bill of materials), allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the <code>quarkus-maven-plugin</code>, responsible for the packaging of the application and also providing the development mode support.</p> <p>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</p>"},{"location":"hero-microservice/#the-jax-rs-resource","title":"The JAX-RS Resource","text":"<p>During the project creation, the <code>HeroResource.java</code> file has been created with the following content:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.logging.Log;\nimport io.smallrye.common.annotation.RunOnVirtualThread;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.jboss.resteasy.reactive.RestResponse;\n\nimport java.net.URI;\nimport java.util.List;\n\n@Path(\"/api/heroes\")\n@RunOnVirtualThread\npublic class HeroResource {\n\n    @GET\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello from Quarkus REST\";\n    }\n</code></pre> <p>It\u2019s a very simple REST endpoint, returning \u201chello\u201d to HTTP GET requests to <code>/api/heroes</code>.</p>"},{"location":"hero-microservice/#running-the-application","title":"Running the Application","text":"<p>We are now ready to run our application.</p> <p>You can use either the Quarkus or Apache Maven command-line interface in a Terminal. Open a Terminal by clicking on the hamburger menu (three horizontal lines) located in the upper-left corner of the screen. Navigate to Terminal and select New Terminal from the dropdown menu.</p> <p>Then, run one of the following commands: </p> <p><code>./mvnw quarkus:dev</code></p> <p>or </p> <p><code>quarkus dev</code></p> <pre><code>$  quarkus dev\n[INFO] Scanning for projects...\n[INFO] \n[INFO] ------------------&lt; com.redhat.workshop:hero-service &gt;------------------\n[INFO] Building hero-service 1.0-SNAPSHOT\n[INFO]   from pom.xml\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO] \n[INFO] --- quarkus:3.13.2:dev (default-cli) @ hero-service ---\n[INFO] Invoking resources:3.3.1:resources (default-resources) @ hero-service\n[INFO] Copying 2 resources from src/main/resources to target/classes\n[INFO] Invoking quarkus:3.13.2:generate-code (default) @ hero-service\n[INFO] Invoking compiler:3.13.0:compile (default-compile) @ hero-service\n[INFO] Nothing to compile - all classes are up to date.\n[INFO] Invoking resources:3.3.1:testResources (default-testResources) @ hero-service\n[INFO] skip non existing resourceDirectory /projects/hero/src/test/resources\n[INFO] Invoking quarkus:3.13.2:generate-code-tests (default) @ hero-service\n[INFO] Invoking compiler:3.13.0:testCompile (default-testCompile) @ hero-service\n[INFO] Nothing to compile - all classes are up to date.\n\n----------------------------\n--- Help improve Quarkus ---\n----------------------------\n* Learn more: https://quarkus.io/usage/\n* Do you agree to contribute anonymous build time data to the Quarkus community? (y/n and enter) \n[info] [Quarkus build analytics] Didn't receive the user's answer after 10 seconds. The question will be asked again next time.\n\nListening for transport dt_socket at address: 5005\n2024-08-28 11:39:46,023 INFO  [io.qua.dat.dep.dev.DevServicesDatasourceProcessor] (build-21) Dev Services for default datasource (postgresql) started - container ID is b64fe935733f\n2024-08-28 11:39:46,026 INFO  [io.qua.hib.orm.dep.dev.HibernateOrmDevServicesProcessor] (build-34) Setting quarkus.hibernate-orm.database.generation=drop-and-create to initialize Dev Services managed database\n__  ____  __  _____   ___  __ ____  ______ \n --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\   \n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n2024-08-28 11:39:46,603 WARN  [io.qua.config] (Quarkus Main Thread) Unrecognized configuration key \"quarkus.smallrye-openapi.store-schema-directory\" was provided; it will be ignored; verify that the dependency extension for this configuration is set or that you did not make a typo\n2024-08-28 11:39:48,103 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) SQL Warning Code: 0, SQLState: 00000\n2024-08-28 11:39:48,105 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) table \"myentity\" does not exist, skipping\n2024-08-28 11:39:48,106 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) SQL Warning Code: 0, SQLState: 00000\n2024-08-28 11:39:48,106 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) sequence \"myentity_seq\" does not exist, skipping\n2024-08-28 11:39:48,316 INFO  [io.quarkus] (Quarkus Main Thread) hero-service 1.0-SNAPSHOT on JVM (powered by Quarkus 3.13.2) started in 7.445s. Listening on: http://0.0.0.0:8080\n2024-08-28 11:39:48,317 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2024-08-28 11:39:48,317 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, hibernate-validator, jdbc-postgresql, micrometer, narayana-jta, rest, rest-jackson, smallrye-context-propagation, smallrye-health, vertx]\n\n--\nTests paused\nPress [e] to edit command line args (currently ''), [r] to resume testing, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre> <p>Then check that the endpoint returns <code>hello</code> as expected:</p> <pre><code>$ curl $URL/api/heroes\nHello from Quarkus REST\n</code></pre> <p>where <code>$URL</code> is the running service endpoint (host + port number).</p> <p>Alternatively, you can open <code>$URL/api/heroes</code> in your browser.</p>"},{"location":"hero-microservice/#development-mode","title":"Development Mode","text":"<p><code>quarkus:dev</code> runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and invoke a REST endpoint (i.e. cUrl command or refresh your browser), these changes will automatically take effect.</p> <p>This works as well for resource files like the configuration property and HTML files. Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</p> <p>The development mode also allows debugging and listens for a debugger on port 5005. If you want to wait for the debugger to attach before running you can pass <code>-Dsuspend=true</code> on the command line. If you don\u2019t want the debugger at all you can use <code>-Ddebug=false</code>.</p> <p>Alright, time to change some code. Open your favorite IDE and import the project. To check that the hot reload is working, update the method <code>HeroResource.hello()</code> by returning the String \u201chello hero\u201d. Now, execute the cUrl command again, the output has changed without you to having to stop and restart Quarkus:</p>"},{"location":"hero-microservice/#testing-the-application","title":"Testing the Application","text":"<p>So far so good, but wouldn\u2019t it be better with a few tests, just in case?</p> <p>In the generated <code>pom.xml</code> file, you can see 2 test dependencies:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;\n    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Quarkus supports JUnit 4 and JUnit 5 tests. In the generated project, we use JUnit 5.</p> <p>We also set the <code>java.util.logging</code> system property to make sure tests will use the correct log manager.</p> <pre><code>&lt;plugin&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${surefire-plugin.version}&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;systemPropertyVariables&gt;\n            &lt;java.util.logging.manager&gt;org.jboss.logmanager.LogManager&lt;/java.util.logging.manager&gt;\n            &lt;maven.home&gt;${maven.home}&lt;/maven.home&gt;\n        &lt;/systemPropertyVariables&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>The generated project contains a simple test in <code>HeroResourceTest.java</code>.</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.NOT_FOUND;\nimport static jakarta.ws.rs.core.Response.Status.NO_CONTENT;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass HeroResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n                .when()\n                .get(\"/api/heroes/hello\")\n                .then()\n                .statusCode(200)\n                .body(is(\"Hello from Quarkus REST\"));\n    }\n</code></pre> <p>By using the <code>QuarkusTest</code> runner, the <code>HeroResourceTest</code> class instructs JUnit to start the application before the tests. Then, the <code>testHelloEndpoint</code> method checks the HTTP response status code and content.</p> <p>Notice that these tests use RestAssured, but feel free to use your favorite library.</p> <p>Execute it with <code>./mvnw test</code> or from your IDE.</p>"},{"location":"hero-microservice/#continuous-testing","title":"Continuous testing","text":"<p>Quarkus supports continuous testing, where tests run immediately after code changes have been saved.  This allows you to get instant feedback on your code changes. </p> <p>Quarkus detects which tests cover which code, and uses this information to only run the relevant tests when code is changed. When you start Quarkus in dev mode, down the bottom of the screen you should see the following:</p> <p><pre><code>Tests paused, press [r] to resume, [h] for more options&gt;\n</code></pre> Press r and the tests will start running. You should see the status change down the bottom of the screen as they are running, and it should finish with:</p> <pre><code>All 1 test is passing (0 skipped), 1 test was run in 8053ms. Tests completed at 12:11:25.\nPress [e] to edit command line args (currently ''), [r] to re-run, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre>"},{"location":"hero-microservice/#packaging-and-running-the-application","title":"Packaging and Running the Application","text":"<p>The application is packaged using <code>./mvnw package</code> or <code>quarkus build</code>. It produces 2 jar files in <code>/target</code>:</p> <ul> <li><code>rest-hero-1.0-SNAPSHOT.jar</code>: containing just the classes and resources of the projects, it\u2019s the regular artifact produced by the Maven build;</li> <li><code>quarkus-app/quarkus-run.jar</code>: being an executable jar.   Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the <code>target/quarkus-app/lib</code> directory.</li> </ul> <p>The application is now runnable from a terminal by running <code>java -jar target/quarkus-app/quarkus-run.jar</code>. </p>"},{"location":"open-api/","title":"Open API","text":""},{"location":"open-api/#open-api","title":"Open-API","text":""},{"location":"overview/","title":"Overview","text":"<p>This workshop illustrates how to build intelligent applications using:</p> <ul> <li>Red Hat OpenShift</li> <li>Red Hat OpenShift AI/ML Services</li> <li>Quarkus</li> <li>Red Hat Developer Hub</li> <li>Red Hat Trusted Application Pipelines</li> </ul> <p>This workshop covers both the development and deployment of such applications on OpenShift as well as the integration with OpenShift AI/ML Services.</p> <p>It proposes a platform engineering approach to the development of intelligent applications. Thus, the code is developed in CodeSpaces and the deployment is done using Trusted Application Pipelines. The different application components run in OpenShift.</p>"},{"location":"overview/#the-application","title":"The application","text":"<p>In this workshop you will develop an application that allows super-heroes to fight against villains. </p> <p></p> <p>Being a workshop about microservices, you will be developing several microservices communicating synchronously via REST API endpoints:</p> <ul> <li><code>frontend</code>: a web application that allows users to pick up a random super-hero, a random villain and makes them fight. The Super Hero UI invokes the Hero, Villain and Fight REST endpoints.</li> <li><code>hero-service</code>: a Quarkus microservice that provides CRUD operations on Heroes which are stored in a PostgresSQL database.</li> <li><code>villain-service</code>: the counterpart of the hero service, for villains.</li> <li><code>fight-service</code>: a microservice that simulates a fight between a hero and a villain. The simulation is done using a Large Language Model (LLM) that is deployed on OpenShift AI/ML Services. The result also includes a short narration of the fight:</li> </ul> <p></p>"},{"location":"overview/#the-architecture","title":"The architecture","text":"<p>Hero and Villain services</p> <p>The <code>hero-service</code> and <code>villain-service</code> are very similar, yet they use different development models. While both are Quarkus applications, the hero service uses the idiomatic Quarkus development model, while the villain service uses the Spring compatibility support from Quarkus.</p>"},{"location":"requirements/","title":"Software Requirements","text":"<p>First of all, make sure you that have a web browser installed on your laptop and proper internet connectivity.</p> <p>Your environment is remote and can be accessed via Red Hat Developer Hub through your local browser: you just need to navigate to the url available on the physical card you have been given and sign in using the credentials.</p> <p>Your environment includes: - Dev Spaces: an in-browser IDE for rapid cloud application development. This where you are going to write Java code. - OpenShift Container Platform: an OpenShift cluster where you are going to deploy the Quarkus microservices. - \u2026</p>"},{"location":"requirements/#access-to-red-hat-developer-hub-rhdh","title":"Access to Red Hat Developer Hub (RHDH)","text":"<p>Go to the RHDH url. A login page should be shown.</p> <p></p> <p>Introduce the login and password provided and select GitLab as Sign In mode. You should be redirected to the GitLab authentication page.</p> <p></p> <p>Enter the login and password provided. The Red Hat Developer Hub home page should be displayed.</p> <p></p> <p>This page shows an overview of your environement with all available tools.</p>"},{"location":"transactions-orm/","title":"Transactions and ORM","text":"<p>The Hero API\u2019s role is to allow CRUD operations on Super Heroes. In this module we will create a Hero entity and persist/update/delete/retrieve it from a Postgres database in a transactional way.</p>"},{"location":"transactions-orm/#directory-structure","title":"Directory Structure","text":"<p>In this module we will add extra classes to the Hero API project. You will end-up with the following directory structure:</p> <p></p>"},{"location":"transactions-orm/#database-dependencies","title":"Database dependencies","text":"<p>This microservice:</p> <ul> <li>interacts with a PostGreSQL database - so it needs a driver</li> <li>uses Hibernate with Panache - so need the dependency on it</li> <li>validates payloads and entities - so need a validator</li> <li>consumes and produces JSON - so we need a mapper</li> </ul> <p>Hibernate ORM is the de-facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.</p> <p>Because JPA and Bean Validation work well together, we will use Bean Validation to constrain our business model.</p> <p>All the needed dependencies to access the database are already in the pom.xml file. Check that you have the following:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-rest-jackson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you need to add them, just run the following command:</p> <pre><code>$ ./mvnw quarkus:add-extension -Dextensions=\"jdbc-postgresql,hibernate-orm-panache,hibernate-validator,rest-jackson\"\n</code></pre> <p>From now on, you can choose to either edit your pom directly or use the <code>quarkus:add-extension</code> command.</p>"},{"location":"transactions-orm/#hero-entity","title":"Hero Entity","text":"<p>To define a Panache entity, simply extend <code>PanacheEntity</code>, annotate it with <code>@Entity</code> and add your columns as public fields (no need to have getters and setters). Create a new java class under <code>src/main/java/io/quarkus/workshop/hero</code> and copy the following content:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.hibernate.orm.panache.PanacheEntity;\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\nimport java.util.Random;\n\n\n@Entity\npublic class Hero extends PanacheEntity {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    public String name;\n\n    public String otherName;\n\n    @NotNull\n    @Min(1)\n    public int level;\n    public String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n    @Override\n    public String toString() {\n        return \"Hero{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", otherName='\" + otherName + '\\'' +\n                \", level=\" + level +\n                \", picture='\" + picture + '\\'' +\n                \", powers='\" + powers + '\\'' +\n                '}';\n    }\n</code></pre> <p>Notice that you can put all your JPA column annotations and Bean Validation constraint annotations on the public fields.</p>"},{"location":"transactions-orm/#adding-operations","title":"Adding Operations","text":"<p>Thanks to Panache, once you have written the <code>Hero</code> entity, here are the most common operations you will be able to do:</p> <pre><code>// creating a hero\nHero hero = new Hero();\nhero.name = \"Superman\";\nhero.level = 9;\n\n// persist it\nhero.persist();\n\n// getting a list of all Hero entities\nList&lt;Hero&gt; heroes = Hero.listAll();\n\n// finding a specific hero by ID\nhero = Hero.findById(id);\n\n// counting all heroes\nlong countAll = Hero.count();\n</code></pre> <p>But we are missing a business method: we need to return a random hero. For that it\u2019s just a matter to add the following method to our <code>Hero.java</code> entity:</p> <pre><code>public static Hero findRandom() {\n    Random random = new Random();\n    var count = count();\n    var index = random.nextInt((int) count);\n    return findAll().page(index, 1).firstResult();\n}\n</code></pre> <p>NOTE</p> <p>You would need to add the following import statement if not done automatically by your IDE <code>import java.util.Random;</code></p>"},{"location":"transactions-orm/#configuring-hibernate","title":"Configuring Hibernate","text":"<p>As Quarkus supports the automatic provisioning of unconfigured services in development and test mode, we don\u2019t need at the moment to configure anything regarding the database access.  Quarkus will automatically start a Postgresql service and wire up your application to use this service. </p> <p>Quarkus development mode is really useful for applications that mix front end or services and database access. We use <code>quarkus.hibernate-orm.database.generation=drop-and-create</code> in conjunction with <code>import.sql</code> so every change to your app and in particular to your entities, the database schema will be properly recreated and your data (stored in <code>import.sql</code>) will be used to repopulate it from scratch. This is best to perfectly control your environment and works magic with Quarkus live reload mode: your entity changes or any change to your <code>import.sql</code> is immediately picked up and the schema updated without restarting the application!</p> <p>For that, make sure to have the following configuration in your <code>application.properties</code> (located in <code>src/main/resources</code>):</p> <pre><code>quarkus.hibernate-orm.database.generation=drop-and-create\n</code></pre>"},{"location":"transactions-orm/#adding-data","title":"Adding Data","text":"<p>To load some data when Hibernate ORM starts, add the following SQL statements in the <code>import.sql</code> in the root of the <code>resources</code> directory. This is useful to have a data set ready for the tests or demos.</p> <pre><code>ALTER SEQUENCE hero_seq RESTART WITH 50;\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Spider-Man', 'Miles Morales', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/10647.jpg', 'Acrobatics, Agility, Animal Attributes, Animal Oriented Powers, Danger Sense, Gadget Usage, Jump, Reflexes, Stamina, Stealth, Substance Secretion, Surface Scaling, Thread Manipulation, Wallcrawling, Web Creation, Accelerated Healing, Acid Resistants, Camouflage, Dexterity, Electrokinesis, Endurance, Energy Blasts, Energy Manipulation, Enhanced Hearing, Enhanced Sight, Enhanced Smell, Extrasensory Perception, Heat Resistance, Indomitable Will, Instinctive Reaction, Master Martial Artist, Power Suit, Radar Sense, Toxin and Disease Resistance, Vision - Microscopic, Vision - Night, Vision - Telescopic, Weapons Master, Afterimage Creation, Audio Control, Heat Generation, Illusion Resistance, Immortality, Invisibility, Longevity, Mind Control Resistance, Precognition, Radiation Immunity, Regeneration', '828');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Valkyrie', 'Brunnhilde', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/12730.jpg', 'Corruption Resistance, Durability, Godly Physiology, Intelligence, Longevity, Master Martial Artist, Stamina, Super Speed, Super Strength, Swordsmanship, Accelerated Healing, Acrobatics, Adaptation, Agility, Cold Resistance, Dexterity, Endurance, Enhanced Memory, Enhanced Sight, Enhanced Smell, Fire Resistance, Heat Resistance, Jump, Leadership, Magic Resistance, Marksmanship, Master Tactician, Multilingualism, Reflexes, Stealth, Vehicular Mastery, Weapon-based Powers, Weapons Master, Regeneration', '415');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Iron Man (What if...?)', 'Tony Stark', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/64233.jpg', 'Durability, EMP Generation, Gadget Usage, Intelligence, Intuitive aptitude, Master Tactician, Mechanical Aptitude, Power Suit, Super Speed, Super Strength, Vehicular Mastery, Agility, Changing Armor, Cold Resistance, Electricity Absorption, Electricity Resistance, Energy Absorption, Energy Resistance, Explosion Manipulation, Flight, Heat Generation, Heat Resistance, Information Analysis, Levitation, Preparation, Reflexes, Technopath/Cyberpath, Weapon-based Powers, Weapons Master, Electro-Magnetism Manipulation, Master Martial Artist', '721');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Zuko', 'Zuko', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/10820.jpg', 'Acrobatics, Agility, Durability, Element Control, Fire Control, Fire Resistance, Heat Generation, Heat Resistance, Intelligence, Jump, Peak Human Condition, Reflexes, Stamina, Super Breath, Super Speed, Super Strength, Adaptation, Attack Reflection, Danger Sense, Electrical Transport, Electricity Absorption, Electricity Resistance, Endurance, Energy Beams, Energy Blasts, Energy Resistance, Marksmanship, Master Martial Artist, Stealth', '439');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Batman', 'Bruce Wayne', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/59602.jpg', 'Acrobatics, Changing Armor, Cold Resistance, Dexterity, Disarmament, Disguise Mastery, Durability, Endurance, Explosion Manipulation, Fearless, Gliding, Grappling/Climbing, Heat Generation, Homing Attack, Ice Manipulation, Indomitable Will, Information Analysis, Intelligence, Intimidation, Laser Manipulation, Master Martial Artist, Master Tactician, Pain Suppression, Peak Human Condition, Power Suit, Preparation, Pressure Points, Reflexes, Scanning, Social Influencing, Stamina, Sub-Mariner, Swimming, Throwing Proficiency, Vehicular Mastery, Vision - X-Ray, Weapon-based Powers, Weapons Master, Accelerated Healing, Animal Control, Camouflage, Electricity Resistance, Electrokinesis, Energy Beams, Enhanced Condition, Extrasensory Perception, Fear Inducement, Invisibility, Mind Control Resistance, Smoke Manipulation, Sonar, Space Survivability, Weapon Creation, Agility, Animal Oriented Powers, Element Control, Flight, Heat Resistance, Shockwaves Generation, Size Changing, Spaceflight, Toon Force, Weapon Summoning', '842');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Double Trouble', '', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/43709.jpg', 'Arcane Magic, Cloning, Insanity, Magic', '128');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Billy Lane', '', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/55865.jpg', 'Agility, Archery, Marksmanship, Peak Human Condition, Swordsmanship, Master Martial Artist, Master Tactician, Postcognition, Stamina, Weapons Master', '18');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Cynthia', '', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/49000.jpg', 'Accelerated Healing, Damage Boost, Damage Reduction, Damage Transferal, Durability, Durability Negation, Fire Control, Fire Resistance, Non-Physical Interaction, Summoning, Vitakinesis, Animal Control, Astral Projection, Attack Negation, Attack Reflection, Aura, Electrical Transport, Electricity Absorption, Electricity Resistance, Electro-Magnetism Manipulation, Electrokinesis, Element Control, Elemental Transformation, Homing Attack, Information Analysis, Plant Control, Power Modification, Power Nullifier, Regeneration, Regeneration Negation, Telekinesis, Toxin and Disease Control, Teleportation, Toxin and Disease Resistance', '944');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Atom', '', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/22445.jpg', 'Durability, Endurance, Information Analysis, Master Martial Artist, Stamina, Super Speed, Super Strength, Adaptation, Agility, Dexterity, Enhanced Condition, Cold Resistance, Enhanced Touch, Fire Control, Heat Resistance', '64');\nINSERT INTO hero(id, name, otherName, picture, powers, level)\nVALUES (nextval('hero_seq'), 'Sonya Blade', '', 'https://raw.githubusercontent.com/cescoffier/quarkus-super-heroes-pictures/main/pictures/10962.jpg', 'Acrobatics, Agility, Durability, Endurance, Enhanced Condition, Intelligence, Master Martial Artist, Peak Human Condition, Stamina, Weapons Master, Electrokinesis, Energy Blasts, Explosion Manipulation, Homing Attack, Indomitable Will, Marksmanship, Master Tactician, Paralysis, Preparation, Reflexes, Sense Manipulation, Weapon Summoning, Blessed, Fire Control, Self-Destruction, Smoke Manipulation', '143');\n</code></pre> <p>Ok, but that\u2019s just a few entries. Download the SQL file import.sql and copy it under <code>src/main/resources</code>. Now, you have around 500 heroes that will be loaded in the database.</p>"},{"location":"transactions-orm/#heroresource-endpoint","title":"HeroResource Endpoint","text":"<p>The <code>HeroResource</code> Endpoint was bootstrapped with only one method <code>hello()</code>. We need to add extra methods that will allow CRUD operations on heroes.</p>"},{"location":"transactions-orm/#making-heroresource-transactional","title":"Making HeroResource Transactional","text":"<p>To manipulate the <code>Hero</code> entity we need make <code>HeroResource</code> transactional. The idea is to wrap methods modifying the database (e.g. <code>entity.persist()</code>) within a transaction. Marking a CDI bean method <code>@Transactional</code> will do that for you and make that method a transaction boundary.</p> <p><code>@Transactional</code> can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.</p> <p>Here are the new methods to add to the <code>HeroResource</code> class:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.logging.Log;\nimport io.smallrye.common.annotation.RunOnVirtualThread;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.jboss.resteasy.reactive.RestResponse;\n\nimport java.net.URI;\nimport java.util.List;\n\n@Path(\"/api/heroes\")\n@RunOnVirtualThread\npublic class HeroResource {\n\n    @GET\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello from Quarkus REST\";\n    }\n\n    //&lt;docHeroCrudContent&gt;\n    @GET\n    @Path(\"/random\")\n    public RestResponse&lt;Hero&gt; getRandomHero() {\n        var hero = Hero.findRandom();\n        if (hero != null) {\n            Log.debugf(\"Found random hero: %s\", hero);\n            return RestResponse.ok(hero);\n        } else {\n            Log.debug(\"No random hero found\");\n            return RestResponse.notFound();\n        }\n    }\n\n    @GET\n    public List&lt;Hero&gt; getAllHeroes() {\n        return Hero.listAll();\n    }\n\n    @GET\n    @Path(\"/{id}\")\n    public RestResponse&lt;Hero&gt; getHero(Long id) {\n        var hero = Hero.&lt;Hero&gt;findById(id);\n        if (hero != null) {\n            return RestResponse.ok(hero);\n        } else {\n            Log.debugf(\"No Hero found with id %d\", id);\n            return RestResponse.notFound();\n        }\n    }\n\n    @POST\n    @Transactional\n    public RestResponse&lt;URI&gt; createHero(@Valid Hero hero, @Context UriInfo uriInfo) {\n        hero.persist();\n        UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(hero.id));\n        Log.debugf(\"New Hero created with URI %s\", builder.build().toString());\n        return RestResponse.created(builder.build());\n    }\n\n    @PUT\n    @Transactional\n    public Hero updateHero(@Valid Hero hero) {\n        Hero retrieved = Hero.findById(hero.id);\n        retrieved.name = hero.name;\n        retrieved.otherName = hero.otherName;\n        retrieved.level = hero.level;\n        retrieved.picture = hero.picture;\n        retrieved.powers = hero.powers;\n        Log.debugf(\"Hero updated with new valued %s\", retrieved);\n        return retrieved;\n    }\n\n    @DELETE\n    @Path(\"/{id}\")\n    @Transactional\n    public RestResponse&lt;Void&gt; deleteHero(Long id) {\n        if (Hero.deleteById(id)) {\n            Log.debugf(\"Hero deleted with %d\", id);\n        }\n        return RestResponse.noContent();\n    }\n    //&lt;/docHeroCrudContent&gt;\n}\n</code></pre> <p>Notice that both methods that persist and update a hero, pass a <code>Hero</code> object as a parameter. Thanks to the Bean Validation\u2019s <code>@Valid</code> annotation, the <code>Hero</code> object will be checked to see if it\u2019s valid or not. It it\u2019s not, the transaction will be rollback-ed.</p> <p>If you didn\u2019t yet, start the application in dev mode:</p> <p><pre><code>$./mvnw quarkus:dev\n</code></pre> or</p> <pre><code>$ quarkus dev\n</code></pre> <p>Then, open your browser to $URL/api/heroes. You should see lots of heroes\u2026</p>"},{"location":"transactions-orm/#configuring-the-datasource-for-production","title":"Configuring the Datasource for Production","text":"<p>Production databases need to be configured as normal.  So if you want to include a production database config in your <code>application.properties</code> and continue to use Dev Services, we recommend that you use the <code>%prod</code> profile to define your database settings.</p> <p>Just add the following datasource configuration in the <code>src/main/resources/application.properties</code> file:</p> <pre><code>%prod.quarkus.datasource.db-kind=postgresql\n%prod.quarkus.datasource.username=${POSTGRESQL_USERNAME}\n%prod.quarkus.datasource.password=${POSTGRESQL_USERNAME}\n%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://hero-database:5432/${POSTGRESQL_DATABASE}\n%prod.quarkus.hibernate-orm.sql-load-script=import.sql\n</code></pre>"},{"location":"transactions-orm/#crud-tests-in-heroresourcetest","title":"CRUD Tests in HeroResourceTest","text":"<p>To test the <code>HeroResource</code> endpoint, we will be using a <code>@QuarkusTest</code> that will fire a Postgres database and then test CRUD operations.</p> <p>In the generated build file, you can see 2 test dependencies:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;\n    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Also, the generated project contains a simple test. Edit the HeroResourceTest.java to match the following content:</p> <pre><code>//&lt;docHeroResourceTest&gt;\npackage io.quarkus.workshop.hero;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.NOT_FOUND;\nimport static jakarta.ws.rs.core.Response.Status.NO_CONTENT;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass HeroResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n                .when()\n                .get(\"/api/heroes/hello\")\n                .then()\n                .statusCode(200)\n                .body(is(\"Hello from Quarkus REST\"));\n    }\n\n    //&lt;docCrudTests&gt;\n    private static final String JSON = \"application/json;charset=UTF-8\";\n\n    private static final String DEFAULT_NAME = \"Super Baguette\";\n    private static final String UPDATED_NAME = \"Super Baguette (updated)\";\n    private static final String DEFAULT_OTHER_NAME = \"Super Baguette Tradition\";\n    private static final String UPDATED_OTHER_NAME = \"Super Baguette Tradition (updated)\";\n    private static final String DEFAULT_PICTURE = \"super_baguette.png\";\n    private static final String UPDATED_PICTURE = \"super_baguette_updated.png\";\n    private static final String DEFAULT_POWERS = \"eats baguette really quickly\";\n    private static final String UPDATED_POWERS = \"eats baguette really quickly (updated)\";\n    private static final int DEFAULT_LEVEL = 42;\n    private static final int UPDATED_LEVEL = 43;\n\n    private static final int NB_HEROES = 500;\n    private static String heroId;\n\n\n    @Test\n    void shouldNotGetUnknownHero() {\n        Long randomId = new Random().nextLong();\n        given()\n                .pathParam(\"id\", randomId)\n                .when()\n                .get(\"/api/heroes/{id}\")\n                .then()\n                .statusCode(NOT_FOUND.getStatusCode());\n    }\n\n    @Test\n    void shouldGetRandomHero() {\n        given()\n                .when()\n                .get(\"/api/heroes/random\")\n                .then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON);\n    }\n\n    @Test\n    void shouldNotAddInvalidItem() {\n        Hero hero = new Hero();\n        hero.name = null;\n        hero.otherName = DEFAULT_OTHER_NAME;\n        hero.picture = DEFAULT_PICTURE;\n        hero.powers = DEFAULT_POWERS;\n        hero.level = 0;\n\n        given()\n                .body(hero)\n                .header(CONTENT_TYPE, APPLICATION_JSON)\n                .header(ACCEPT, APPLICATION_JSON)\n                .when()\n                .post(\"/api/heroes\")\n                .then()\n                .statusCode(BAD_REQUEST.getStatusCode());\n    }\n\n    @Test\n    @Order(1)\n    void shouldGetInitialItems() {\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES, heroes.size());\n    }\n\n    @Test\n    @Order(2)\n    void shouldAddAnItem() {\n        Hero hero = new Hero();\n        hero.name = DEFAULT_NAME;\n        hero.otherName = DEFAULT_OTHER_NAME;\n        hero.picture = DEFAULT_PICTURE;\n        hero.powers = DEFAULT_POWERS;\n        hero.level = DEFAULT_LEVEL;\n\n        String location = given()\n                .body(hero)\n                .header(CONTENT_TYPE, APPLICATION_JSON)\n                .header(ACCEPT, APPLICATION_JSON)\n                .when()\n                .post(\"/api/heroes\")\n                .then()\n                .statusCode(CREATED.getStatusCode())\n                .extract()\n                .header(\"Location\");\n        assertTrue(location.contains(\"/api/heroes\"));\n\n        // Stores the id\n        String[] segments = location.split(\"/\");\n        heroId = segments[segments.length - 1];\n        assertNotNull(heroId);\n\n        given()\n                .pathParam(\"id\", heroId)\n                .when()\n                .get(\"/api/heroes/{id}\")\n                .then()\n                .statusCode(OK.getStatusCode())\n                .body(\"name\", Is.is(DEFAULT_NAME))\n                .body(\"otherName\", Is.is(DEFAULT_OTHER_NAME))\n                .body(\"level\", Is.is(DEFAULT_LEVEL))\n                .body(\"picture\", Is.is(DEFAULT_PICTURE))\n                .body(\"powers\", Is.is(DEFAULT_POWERS));\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES + 1, heroes.size());\n    }\n\n    @Test\n    @Order(3)\n    void shouldUpdateAnItem() {\n        Hero hero = new Hero();\n        hero.id = Long.valueOf(heroId);\n        hero.name = UPDATED_NAME;\n        hero.otherName = UPDATED_OTHER_NAME;\n        hero.picture = UPDATED_PICTURE;\n        hero.powers = UPDATED_POWERS;\n        hero.level = UPDATED_LEVEL;\n\n        given()\n                .body(hero)\n                .header(CONTENT_TYPE, APPLICATION_JSON)\n                .header(ACCEPT, APPLICATION_JSON)\n                .when()\n                .put(\"/api/heroes\")\n                .then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .body(\"name\", Is.is(UPDATED_NAME))\n                .body(\"otherName\", Is.is(UPDATED_OTHER_NAME))\n                .body(\"level\", Is.is(UPDATED_LEVEL))\n                .body(\"picture\", Is.is(UPDATED_PICTURE))\n                .body(\"powers\", Is.is(UPDATED_POWERS));\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES + 1, heroes.size());\n    }\n\n    @Test\n    @Order(4)\n    void shouldRemoveAnItem() {\n        given()\n                .pathParam(\"id\", heroId)\n                .when()\n                .delete(\"/api/heroes/{id}\")\n                .then()\n                .statusCode(NO_CONTENT.getStatusCode());\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES, heroes.size());\n    }\n\n    private TypeRef&lt;List&lt;Hero&gt;&gt; getHeroTypeRef() {\n        return new TypeRef&lt;List&lt;Hero&gt;&gt;() {\n            // Kept empty on purpose\n        };\n    }\n\n    //&lt;/docCrudTests&gt;\n}\n//&lt;/docHeroResourceTest&gt;\n</code></pre> <p>The following test methods have been added to the <code>HeroResourceTest</code> class:</p> <ul> <li><code>shouldNotGetUnknownHero</code>: giving a random Hero identifier, the <code>HeroResource</code> endpoint should return a 204 (No content)</li> <li><code>shouldGetRandomHero</code>: checks that the <code>HeroResource</code> endpoint returns a random hero</li> <li><code>shouldNotAddInvalidItem</code>: passing an invalid <code>Hero</code> should fail when creating it (thanks to the <code>@Valid</code> annotation)</li> <li><code>shouldGetInitialItems</code>: checks that the <code>HeroResource</code> endpoint returns the list of heroes</li> <li><code>shouldAddAnItem</code>: checks that the <code>HeroResource</code> endpoint creates a valid <code>Hero</code></li> <li><code>shouldUpdateAnItem</code>: checks that the <code>HeroResource</code> endpoint updates a newly created <code>Hero</code></li> <li><code>shouldRemoveAnItem</code>: checks that the <code>HeroResource</code> endpoint deletes a hero from the database</li> </ul> <p>Let\u2019s have a look to the 2 annotations used on the HeroResourceTest class.  <code>@QuarkusTest</code> indicates that this test class is checking the behavior of a Quarkus application.  The test framework starts the application before the test class and stops it once all the tests have been executed.  In our case, we just execute HTTP requests to check the result.</p> <p>With this code written, execute the test using <code>./mvnw test</code>. The test should pass.</p>"},{"location":"trusted-apps/","title":"Red Hat Trusted Application Pipelines","text":""},{"location":"trusted-apps/#security-issue","title":"Security issue","text":"<p>guava-cve-issue</p>"},{"location":"villain-microservice/","title":"Creating the Villain Microservice","text":"<p>New microservice, new project!  In this section we will see the counterpart of the Hero microservice: the Villain microservice. The Villain REST Endpoint is really similar to the Hero Endpoint but has been developed using the Spring compatibility layer provided by Quarkus. The Quarkus Spring compatibility extensions map Spring APIs to APIs in existing extensions that have already been optimized for fast startup, reduced memory utilization and native compilation, like RestEasy and CDI. While users are encouraged to use Quarkus extensions, this compatibility layer is provided to make developing new applications with Quarkus a natural getting started experience. Be aware that Quarkus Spring compatibility extensions do not utilize the Spring application context.  For this reason, attempting to utilize additional Spring libraries will likely not work.</p>"},{"location":"villain-microservice/#bootstrapping-the-villain-rest-endpoint","title":"Bootstrapping the Villain Rest Endpoint","text":"<p>The code is now fully available and you will not have to write any of this microservice. To set up the project, simply create it from the specified template, which will automatically pull the complete code from the GitHub repository.</p>"},{"location":"villain-microservice/#red-hat-developer-hub-software-templates-and-dev-spaces-workspace","title":"Red Hat Developer Hub Software templates and Dev Spaces workspace.","text":"<p>Like the Hero microservice creation, to create a Dev Spaces (DS) workspace, you\u2019ll first need to create a Software Component using a Red Hat Developer Hub (RHDH) Software Template:</p> <ol> <li>Navigate to the Create Option: in the left-hand menu of the RHDH, click on the \u201cCreate\u201d option.</li> <li>Select the template: you\u2019ll see a list of available templates. Choose the <code>OpenCodeQuest - Quarkus using Spring Extension with Postgresq</code> template from the list.</li> <li>Configure the workspace: after selecting the template, you\u2019ll need to provide the necessary values for clusters and other configurations. Most of these fields will be pre-filled by default, so you may only need to make minor adjustments if necessary.</li> <li>Proceed with the setup: Once you\u2019ve reviewed the configurations, proceed to create your DS workspace.</li> </ol> <p>Once created, the component is available in the catalog. You can access it to have an overview:</p> <p></p> <p>Launch the Dev Spaces creation by clicking the link OpenShift Dev Spaces (VS Code).</p>"},{"location":"villain-microservice/#the-villain-service","title":"The Villain Service","text":"<p>At the heart of the Super Hero application come also  villains.</p> <p>We need to expose a REST API allowing CRUD operations on super heroes. This microservice is also a classical microservice. It uses HTTP to expose a REST API, and it internally stores data into a database.</p> <p>This service will be used by the fight microservice.</p> <p>In the following sections, you will learn:</p> <ul> <li>how to implement REST API using Quarkus Spring web extension, and</li> <li>how to compose your application using CDI beans injected with Quarkus Spring CDI, and</li> <li>how to access your database using Quarkus Spring Data JPA, and</li> <li>how to use transactions, and</li> </ul>"},{"location":"villain-microservice/#directory-structure","title":"Directory Structure","text":"<p>Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:</p> <p></p> <p>It generates the following in the <code>villain-service</code> folder:</p> <ul> <li>the Maven structure with a <code>pom.xml</code></li> <li>an <code>io.quarkus.workshop.villain.VillainController</code> controller exposed on <code>/api/heroes</code></li> <li>an associated unit test <code>VillainControllerTest</code></li> <li>example <code>Dockerfile</code> files for both native and jvm modes in <code>src/main/docker</code></li> <li>the <code>application.properties</code> configuration file</li> </ul> <p>Once generated, look at the <code>pom.xml</code>. You will find the here import of the Quarkus BOM (bill of materials), allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the <code>quarkus-maven-plugin</code>, responsible for the packaging of the application and also providing the development mode support.</p> <p>If we focus on the dependencies section, you can see basically the same dependencies than the hero-service plus the <code>quarkus-spring-web</code> and <code>quarkus-spring-data</code></p>"},{"location":"villain-microservice/#the-controller","title":"The Controller","text":"<p>During the project creation, the <code>VillainController.java</code> file has been created with the following content:</p> <pre><code>package io.quarkus.workshop.villain;\n\nimport io.quarkus.logging.Log;\nimport io.smallrye.common.annotation.RunOnVirtualThread;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.DeleteMapping;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.server.ResponseStatusException;\n\nimport java.net.URI;\nimport java.util.List;\n\n@RunOnVirtualThread\n@RestController\n@RequestMapping(value = \"/api/villains\")\npublic class VillainController {\n\n\n    private final VillainRepository repository;\n\n    public VillainController(VillainRepository repository) {\n        this.repository = repository;\n    }\n\n    @GetMapping(\"/random\")\n    public ResponseEntity&lt;Villain&gt; getRandomVillain() {\n        var villain = repository.findRandom();\n        if (villain != null) {\n            Log.debugf(\"Found random villain: %s\", villain);\n            return ResponseEntity.ok(villain);\n        } else {\n            Log.debug(\"No random villain found\");\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @GetMapping\n    public List&lt;Villain&gt; getAllVillains() {\n        return repository.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Villain&gt; getVillain(Long id) {\n        var villain = repository.findById(id).orElse(null);\n        if (villain != null) {\n            return ResponseEntity.ok(villain);\n        } else {\n            Log.debugf(\"No Villain found with id %d\", id);\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @PostMapping\n    @Transactional\n    public ResponseEntity&lt;URI&gt; createVillain(@Valid Villain villain, @Context UriInfo uriInfo) {\n        var persisted = repository.save(villain);\n        UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(persisted.getId()));\n        Log.debugf(\"New Villain created with URI %s\", builder.build().toString());\n        return ResponseEntity.created(builder.build()).build();\n    }\n\n    @PutMapping\n    @Transactional\n    public Villain updateVillain(@Valid Villain villain) {\n        Villain retrieved = repository.findById(villain.getId()).orElseThrow(\n                () -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, \"Villain not found\"));\n        retrieved.setName(villain.getName());\n        retrieved.setOtherName(villain.getOtherName());\n        retrieved.setLevel(villain.getLevel());\n        retrieved.setPicture(villain.getPicture());\n        retrieved.setPowers(villain.setPowers());\n        Log.debugf(\"Villain updated with new valued %s\", retrieved);\n        return retrieved;\n    }\n\n    @DeleteMapping(\"/{id}\")\n    @Transactional\n    public ResponseEntity&lt;Void&gt; deleteVillain(Long id) {\n        repository.deleteById(id);\n        return ResponseEntity.noContent().build();\n    }\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello Villain Service\";\n    }\n}\n</code></pre> <p>It\u2019s a very simple REST endpoint, returning \u201chello\u201d to HTTP GET requests to <code>/api/heroes</code>.</p> <p>This controller exposes CRUD operations to \u201cvillains\u201d and leverages Spring Web and Spring Data JPA annotations for handling HTTP requests and transactions:</p> <ol> <li> <p>@RestController: Marks the class as a RESTful controller where every method returns a JSON response instead of a view. </p> </li> <li> <p>@RequestMapping: Specifies the base URL path (<code>/api/villains</code>) for all the endpoints within this controller. It replaces the standard JAX-RS <code>@Path</code></p> </li> <li> <p>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping: These annotations define HTTP methods (GET, POST, PUT, DELETE) to map specific endpoints to CRUD operations.</p> </li> </ol> <p>Not Spring specific annotations but used like in the hero-service:</p> <ol> <li> <p>@Transactional: Ensures that the methods annotated with it are executed within a transaction context, which automatically commits or rolls back the transaction.</p> </li> <li> <p>@Valid: Validates the input entity (<code>Villain</code>) based on the constraints defined on its fields.</p> </li> <li> <p>@Context: Injects <code>UriInfo</code>, which provides contextual information about the current URI to help in creating new URIs for created resources.</p> </li> <li> <p>@RunOnVirtualThread: Runs the controller on a virtual thread for better concurrency management. This is specific to the SmallRye library.</p> </li> </ol>"},{"location":"villain-microservice/#accessing-database","title":"Accessing Database","text":"<p>As everything is in place the <code>import.sql</code> file contains already all SQL statements to populate the villain database.</p>"},{"location":"villain-microservice/#the-villain-repository","title":"The Villain repository","text":"<p>As we are following a Spring Data programming model with JPA,we need to extend the JPA specific Repository interface, JpaRepository.  This will enable Quarkus to find this interface and automatically create an implementation for it. By extending the interface, we get the most relevant CRUD methods automatically. </p> <p>You can check the <code>VillainRepository.java</code> code. It also contains a more specific method to retrieve a villain randomly from database:</p> <pre><code>default Villain findRandom() {\n    var count = count();\n    var index = (int) (Math.random() * count);\n    return findAll().get(index);\n}\n</code></pre>"},{"location":"villain-microservice/#the-villain-entity","title":"The Villain entity","text":"<p>Finally we have an entity class representing the villains.</p> <pre><code>package io.quarkus.workshop.villain;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\n\n@Entity\npublic class Villain {\n\n    @Id\n    @SequenceGenerator(name = \"villainSequence\", sequenceName = \"villain_seq\", allocationSize = 1, initialValue = 10)\n    @GeneratedValue(generator = \"villainSequence\")\n    private Long id;\n\n    private String name;\n\n    private String otherName;\n\n\n    private int level;\n    private String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public @NotNull @Size(min = 3, max = 50) String getName() {\n        return name;\n    }\n\n    public void setName(@NotNull @Size(min = 3, max = 50) String name) {\n        this.name = name;\n    }\n\n    public String getOtherName() {\n        return otherName;\n    }\n\n    public void setOtherName(String otherName) {\n        this.otherName = otherName;\n    }\n\n    @NotNull\n    @Min(1)\n    public int getLevel() {\n        return level;\n    }\n\n    public void setLevel(@NotNull @Min(1) int level) {\n        this.level = level;\n    }\n\n    public String getPicture() {\n        return picture;\n    }\n\n    public void setPicture(String picture) {\n        this.picture = picture;\n    }\n\n    public String setPowers() {\n        return powers;\n    }\n\n    public void setPowers(String powers) {\n        this.powers = powers;\n    }\n}\n</code></pre>"},{"location":"villain-microservice/#tests","title":"Tests","text":"<p>As in the case of the heroes, the tests could not be missing here.  A test class is provided and contains the basic tests to ensure that the villain microservice works correctly.</p> <p>You can check that everything works fine by starting the application in development mode.</p> <p>run one of the following commands:</p> <p><code>./mvnw quarkus:dev</code></p> <p>or</p> <p><code>quarkus dev</code></p> <pre><code>\n</code></pre> <p>Note that the tests have been successful run. </p> <p>Alternatively, you can open <code>$URL/api/villains</code> in your browser and you should get lots of villains.</p>"},{"location":"web-application/","title":"User Interface","text":""},{"location":"web-application/#the-web-application","title":"The Web Application","text":"<p>This application exposes the user interface to make the fight.</p> <p>The user interface is written in JavaScript using React, and the compiled assets are exposed from a Quarkus microservice.</p> <p>The application also performs some service composition logic, as it makes HTTP client requests to the heroes, villains and fight services:</p> <p></p>"},{"location":"web-application/#bootstrapping-the-web-application-endpoint","title":"Bootstrapping the Web Application Endpoint","text":"<p>The code is now fully available and you will not have to write any of this microservice.</p> <p>To set up the project, simply create it from the specified template, which will automatically pull the complete code from the GitHub repository.</p>"},{"location":"web-application/#setting-up-environment-variables","title":"Setting up environment variables","text":"<p>The service needs the following 3 environment variables to point to the heroes, villains and fight services:</p> <ul> <li><code>ENDPOINTS_HEROES</code> (e.g., <code>http://user2-hero-dev:8080/api/heroes/random</code>)</li> <li><code>ENDPOINTS_VILLAINS</code> (e.g., <code>http://user2-villain-dev:8080/api/villains/random</code>)</li> <li><code>ENDPOINTS_FIGHT</code> (e.g., <code>http://user2-fight-dev:8080/api/fights</code>)</li> </ul>"},{"location":"requirements/dev-spaces/","title":"Software Requirements","text":"<p>First of all, make sure you have Web browser installed on your laptop and internet connectivity.</p> <p>Your environment is remote and can be accessed via DevSpaces through your local browser, you just need to sign up and configure some elements. Your environment includes also Red Hat\u2019s OpenShift Container Platform (OCP).</p> <p>The next section focuses on how to install and setup the needed software.</p>"},{"location":"requirements/dev-spaces/#red-hat-openshift-dev-spaces","title":"Red Hat OpenShift Dev Spaces","text":"<p>Red Hat OpenShift Dev Spaces  Workspaces is a collaborative Kubernetes-native development solution that delivers OpenShift workspaces and in-browser IDE for rapid cloud application development. </p>"},{"location":"requirements/dev-spaces/#dev-spaces-creation","title":"Dev Spaces creation","text":"<p>If everything goes well, you should have a Red Hat OpenShift Dev Spaces  Workspace with a <code>quarkus-workshop</code> folder ready to start to code:</p> <ul> <li>Finally, open a terminal from the Terminal menu \u2192 Open Terminal in     specific container \u2192 maven.</li> </ul>"},{"location":"requirements/dev-spaces/#command-line-utilities","title":"Command Line Utilities","text":"<p>Just make sure the following commands work on your CRW terminal</p> <pre><code>$ java -version\n$ mvn -version\n$ curl --version\n</code></pre>"},{"location":"requirements/openshift-cluster/","title":"OpenShift Container Platform","text":"<p>Your lab environment includes Red Hat\u2019s OpenShift Container Platform (OCP).</p> <p>Access to your OCP resources can be gained via both the <code>oc</code> CLI utility and the OCP web console.</p>"},{"location":"requirements/openshift-cluster/#overview","title":"Overview","text":"<p>The project we are going to develop will contain 3 microservices accessing to a PostgreSQL database.  We will make the databases to run in a OpenShift dedicated namespace.</p>"},{"location":"requirements/openshift-cluster/#openshift-namespaces","title":"OpenShift Namespaces","text":"<ol> <li>In the terminal of your Red Hat OpenShift Dev Spaces , authenticate into OpenShift as a non     cluster admin user (USERNAME) using the <code>oc</code> utility.</li> </ol> <p>You can get the command for authenticating from the OpenShift Web Console.</p> <pre><code>$ oc login\n</code></pre> <p>There are 2 namespaces (OpenShift projects) in your OpenShift cluster: The namespace for hosting your Red Hat OpenShift Dev Spaces environment is USERNAME-devspaces where <code>USERNAME</code> correspond to your specific username. The namespace for hosting databases and microservices is USERNAME-heroes.</p> <p>change the USERNAME with your own.</p>"},{"location":"requirements/openshift-cluster/#operators","title":"Operators","text":"<p>Your lab environment comes pre-installed with an OpenShift operator.</p> <p>PostgreSQL operator</p> <p>The PostgreSQL operator allows to package, install, configure and manage a PostgreSQL database within an OpenShift cluster.</p> <p>Congratulations! Your lab environment is now ready to use.</p>"}]}