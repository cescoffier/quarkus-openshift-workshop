{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"conclusion-references/","title":"Conclusion","text":""},{"location":"conclusion-references/#references","title":"References","text":""},{"location":"containers-cloud/","title":"From Git to OpenShift","text":""},{"location":"containers-cloud/#build-and-deploy","title":"Build and deploy","text":"<p>Build and deploy (in a single step)</p>"},{"location":"containers-cloud/#deploying-others","title":"Deploying others","text":"<p>Deploying the others microservices</p>"},{"location":"fight-microservice/","title":"Intelligent Fight microservice","text":""},{"location":"fight-microservice/#overview-of-llm-integration-in-quarkus","title":"Overview of LLM Integration in Quarkus","text":""},{"location":"fight-microservice/#using-quarkus-langchain4j-extension","title":"Using Quarkus-LangChain4j Extension","text":""},{"location":"fight-microservice/#code-implementation","title":"Code implementation","text":""},{"location":"fight-microservice/#adding-the-quarkus-langchain4j-xxxxx-extension","title":"Adding the quarkus-langchain4j-xxxxx extension","text":""},{"location":"fight-microservice/#defining-llm-interactions-with-registeraiservice","title":"Defining LLM interactions with @RegisterAiService","text":""},{"location":"fight-microservice/#running-testing-and-packaging","title":"Running, testing and packaging","text":""},{"location":"fight-microservice/#custom-metrics","title":"Custom metrics","text":""},{"location":"hero-microservice/","title":"Creating a REST/HTTP Microservice","text":"<p>At the heart of the Super Hero application comes Heroes. We need to expose a REST API allowing CRUD operations on Super Heroes. This microservice is, let\u2019s say, a classical microservice. It uses HTTP to expose a REST API and internally store data into a database. This service will be used by the fight microservice.</p> <p></p> <p>In the following sections, you learn: -   how to create a new Quarkus application using Red Hat DeveloperHub. -   how to implement REST API using JAX-RS. -   how to compose your application using CDI beans. -   how to access your database using Hibernate with Panache. -   how to use transactions. -   how to enable OpenAPI and Swagger-UI.</p> <p>But first, let\u2019s describe our service. The Super Heroes microservice stores super-heroes, with their names, powers, and so on. The REST API allows adding, removing, listing, and picking a random hero from the stored set. Nothing outstanding but a good first step to discover Quarkus.</p>"},{"location":"hero-microservice/#bootstrapping-the-hero-rest-endpoint","title":"Bootstrapping the Hero REST Endpoint","text":"<p>First thing first, we need a project. That\u2019s what your are going to see in this section.</p> <p>Using RH developer hub UI create a quarkus application with default extensions.</p>"},{"location":"hero-microservice/#directory-structure","title":"Directory Structure","text":"<p>Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts :</p> <p></p> <p>It generates the following in the hero-service folder:</p> <ul> <li>the Maven structure with a <code>pom.xml</code></li> <li>an <code>io.quarkus.workshop.superheroes.hero.HeroResource</code> resource exposed on <code>/api/heroes</code></li> <li>an associated unit test <code>HeroResourceTest</code></li> <li>the landing page <code>index.html</code> that is accessible after starting the application</li> <li>example <code>Dockerfile</code> files for both native and jvm modes in <code>src/main/docker</code></li> <li>the <code>application.properties</code> configuration file</li> </ul> <p>Once generated, look at the <code>pom.xml</code>. You will find the import of the Quarkus BOM, allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the <code>quarkus-maven-plugin</code> responsible of the packaging of the application and also providing the development mode.</p> <p>If we focus on the dependencies section, you can see the extension allowing the development of REST applications:</p>"},{"location":"hero-microservice/#the-jax-rs-resource","title":"The JAX-RS Resource","text":"<p>During the project creation, the <code>HeroResource.java</code> file has been created with the following content:</p> <pre><code>package io.quarkus.workshop.superheroes.hero;\n\n@Path(\"/api/heroes\")\npublic class HeroResource {\n\n    @GET\n    @Produces(MediaType.TEXT_PLAIN)\n    public String hello() {\n        return \"hello\";\n    }\n}\n</code></pre> <p>It\u2019s a very simple REST endpoint, returning \u201chello\u201d to requests on <code>/api/heroes</code>.</p>"},{"location":"hero-microservice/#running-the-application","title":"Running the Application","text":"<p>Now we are ready to run our application.Use: <code>./mvnw quarkus:dev</code>:</p> <pre><code>$ ./mvnw quarkus:dev\n[INFO] Scanning for projects...\n[INFO]\n[INFO] -------------&lt; io.quarkus.workshop.super-heroes:rest-hero &gt;-------------\n[INFO] Building rest-hero 1.0-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- quarkus-maven-plugin:1.9.2.Final:dev (default-cli) @ rest-hero ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 2 resources\n[INFO] Nothing to compile - all classes are up to date\nListening for transport dt_socket at address: 5005\n__  ____  __  _____   ___  __ ____  ______\n--/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n-/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\\n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n2020-11-16 10:01:51,331 INFO  [io.quarkus] (Quarkus Main Thread) rest-hero 1.0-SNAPSHOT on JVM (powered by Quarkus 1.9.2.Final) started in 3.797s. Listening on: http://0.0.0.0:8080\n2020-11-16 10:01:51,343 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2020-11-16 10:01:51,343 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy]\n</code></pre> <p>Then check that the endpoint returns <code>hello</code> as expected:</p> <pre><code>$ curl $URL/api/heroes\nhello\n</code></pre> <p>Alternatively, you can open $URL/api/heroes in your browser.</p>"},{"location":"hero-microservice/#development-mode","title":"Development Mode","text":"<p><code>quarkus:dev</code> runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and invoke a REST endpoint (i.e. cUrl command or refresh your browser), these changes will automatically take effect. This works too for resource files like the configuration property and HTML files. Refreshing the browser triggers a scan of the workspace, and if any changes are detected, the Java files are recompiled and the application is redeployed; your request is then serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.</p> <p>The development mode also allows debugging and listens for a debugger on port 5005. If you want to wait for the debugger to attach before running you can pass <code>-Dsuspend=true</code> on the command line. If you don\u2019t want the debugger at all you can use <code>-Ddebug=false</code>.</p> <p>Alright, time to change some code. Open your favorite IDE and import the project. To check that the hot reload is working, update the method <code>HeroResource.hello()</code> by returning the String \u201chello hero\u201d. Now, execute the cUrl command again, the output has changed without you to having to stop and restart Quarkus:</p>"},{"location":"hero-microservice/#testing-the-application","title":"Testing the Application","text":"<p>All right, so far so good, but wouldn\u2019t it be better with a few tests, just in case.</p> <p>In the generated <code>pom.xml</code> file, you can see 2 test dependencies:</p> <p>Quarkus supports Junit 4 and Junit 5 tests. In the generated project, we use Junit 5. Because of this, the version of the Surefire Maven Plugin must be set, as the default version does not support Junit 5:</p> <p>We also set the <code>java.util.logging</code> system property to make sure tests will use the correct log manager.</p> <p>The generated project contains a simple test in <code>HeroResourceTest.java</code>.</p> <pre><code>package io.quarkus.workshop.superheroes.hero;\n\n@QuarkusTest\npublic class HeroResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n          .when().get(\"/api/heroes\")\n          .then()\n             .statusCode(200)\n             .body(is(\"hello\"));\n    }\n}\n</code></pre> <p>By using the <code>QuarkusTest</code> runner, the <code>HeroResourceTest</code> class instructs JUnit to start the application before the tests. Then, the <code>testHelloEndpoint</code> method checks the HTTP response status code and content. Notice that these tests use RestAssured, but feel free to use your favorite library.</p> <p>Execute it with <code>./mvnw test</code> or from your IDE. It fails! It\u2019s expected, you changed the output of <code>HeroResource.hello()</code> earlier. Adjust the test body condition accordingly.</p>"},{"location":"hero-microservice/#packaging-and-running-the-application","title":"Packaging and Running the Application","text":"<p>The application is packaged using <code>./mvnw package</code>. It produces 2 jar files in <code>/target</code>:</p> <ul> <li><code>rest-hero-1.0-SNAPSHOT.jar</code> : containing just the classes and resources of the projects, it\u2019s the regular artifact produced by the Maven build;</li> <li><code>rest-hero-1.0-SNAPSHOT-runner.jar</code> : being an executable jar.   Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the <code>target/lib</code> directory.</li> </ul> <p>You can run the application using: <code>java -jar target/rest-hero-1.0-SNAPSHOT-runner.jar</code>.</p> <p>NOTE Before running the application, don\u2019t forget to stop the hot reload mode (hit CTRL+C), or you will have a port conflict.</p>"},{"location":"open-api/","title":"Open API","text":""},{"location":"open-api/#open-api","title":"Open-API","text":""},{"location":"overview/","title":"Overview","text":"<p>This workshop illustrates how to build intelligent applications using:</p> <ul> <li>OpenShift</li> <li>OpenShift AI/ML Services</li> <li>Quarkus</li> <li>Red Hat Developer Hub</li> <li>Red Hat Trusted Application Pipelines</li> </ul> <p>This workshop covers both the development of such applications and well as its deployment on OpenShift and integration with OpenShift AI/ML Services. It proposes a platform engineering approach to the development of intelligent applications. Thus, the code is developed in CodeSpaces and the deployment is done using Trusted Application Pipelines. The different application components run in OpenShift.</p>"},{"location":"overview/#the-application","title":"The application","text":"<p>In this workshop you will develop an application that allows super-heroes to fight against villains.  Being a workshop about microservices, you will be developing several microservices communicating either synchronously via REST :</p> <ul> <li><code>frontend</code>: a web application that allows users to pick up a random super-hero, a random villain and makes them fight. The Super Hero UI invokes the Hero, Villain and Fight REST endpoints.</li> <li><code>hero-service</code>: a Quarkus microservice that provides CRUD operations on Heroes which are stored in a PostgresSQL database.</li> <li><code>villain-service</code>: the counterpart of the hero service, for villains.</li> <li><code>fight-service</code>: a microservice that simulates a fight between a hero and a villain. The simulation is done using a Large Language Model (LLM) that is deployed on OpenShift AI/ML Services.</li> </ul> <p>Hero and Villain services</p> <p>The <code>hero-service</code> and <code>villain-service</code> are very similar, but both use different development model. While both are Quarkus applications, the hero service uses the idiomatic Quarkus development model, while the villain service uses the Spring compatibility support from Quarkus.</p>"},{"location":"overview/#the-architecture","title":"The architecture","text":""},{"location":"transactions-orm/","title":"Transactions and ORM","text":"<p>The Hero API\u2019s role is to allow CRUD operations on Super Heroes. In this module we will create a Hero entity and persist/update/delete/retrieve it from a Postgres database in a transactional way.</p>"},{"location":"transactions-orm/#directory-structure","title":"Directory Structure","text":"<p>In this module we will add extra classes to the Hero API project. You will end-up with the following directory structure:</p> <p></p>"},{"location":"transactions-orm/#installing-the-postgresql-dependency-hibernate-with-panache-and-hibernate-validator","title":"Installing the PostgreSQL Dependency, Hibernate with Panache and Hibernate Validator","text":"<p>This microservice:</p> <ul> <li>interacts with a PostGreSQL database - so it needs a driver</li> <li>uses Hibernate with Panache - so need the dependency on it</li> <li>validates payloads and entities - so need a validator</li> <li>consumes and produces JSON - so we need a mapper</li> </ul> <p>Hibernate ORM is the de-facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.footnote:[Panache https://github.com/quarkusio/quarkus/tree/master/extensions/panache]</p> <p>Because JPA and Bean Validation work well together, we will use Bean Validation to constrain our business model.</p> <p>To add the required dependencies, just run the following command:</p> <pre><code>$ ./mvnw quarkus:add-extension -Dextensions=\"jdbc-postgresql,hibernate-orm-panache,hibernate-validator,resteasy-jsonb\"\n</code></pre> <p>From now on, you can choose to either edit your pom directly or use the <code>quarkus:add-extension</code> command.</p>"},{"location":"transactions-orm/#hero-entity","title":"Hero Entity","text":"<p>To define a Panache entity, simply extend <code>PanacheEntity</code>, annotate it with <code>@Entity</code> and add your columns as public fields (no need to have getters and setters). The <code>Hero</code> entity should look like this:</p> <p>Notice that you can put all your JPA column annotations and Bean Validation constraint annotations on the public fields.</p>"},{"location":"transactions-orm/#adding-operations","title":"Adding Operations","text":"<p>Thanks to Panache, once you have written the <code>Hero</code> entity, here are the most common operations you will be able to do:</p> <pre><code>// creating a hero\nHero hero = new Hero();\nhero.name = \"Superman\";\nhero.level = 9;\n\n// persist it\nhero.persist();\n\n// getting a list of all Hero entities\nList&lt;Hero&gt; heroes = Hero.listAll();\n\n// finding a specific hero by ID\nhero = Hero.findById(id);\n\n// counting all heroes\nlong countAll = Hero.count();\n</code></pre> <p>But we are missing a business method: we need to return a random hero. For that it\u2019s just a matter to add the following method to our <code>Hero.java</code> entity:</p> <p>NOTE You would need to add the following import statement if not done automatically by your IDE <code>import java.util.Random;</code></p>"},{"location":"transactions-orm/#configuring-hibernate","title":"Configuring Hibernate","text":"<p>Quarkus development mode is really useful for applications that mix front end or services and database access. We use <code>quarkus.hibernate-orm.database.generation=drop-and-create</code> in conjunction with <code>import.sql</code> so every change to your app and in particular to your entities, the database schema will be properly recreated and your data (stored in <code>import.sql</code>) will be used to repopulate it from scratch. This is best to perfectly control your environment and works magic with Quarkus live reload mode: your entity changes or any change to your <code>import.sql</code> is immediately picked up and the schema updated without restarting the application!</p> <p>For that, make sure to have the following configuration in your <code>application.properties</code> (located in <code>src/main/resources</code>):</p>"},{"location":"transactions-orm/#heroservice-transactional-service","title":"HeroService Transactional Service","text":"<p>To manipulate the <code>Hero</code> entity we will develop a transactional <code>HeroService</code> class. The idea is to wrap methods modifying the database (e.g. <code>entity.persist()</code>) within a transaction. Marking a CDI bean method <code>@Transactional</code> will do that for you and make that method a transaction boundary.</p> <p><code>@Transactional</code> can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional. You can control whether and how the transaction is started with parameters on <code>@Transactional</code>:</p> <ul> <li><code>@Transactional(REQUIRED)</code> (default): starts a transaction if none was started, stays with the existing one otherwise.</li> <li><code>@Transactional(REQUIRES_NEW)</code>: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</li> <li><code>@Transactional(MANDATORY)</code>: fails if no transaction was started ; works within the existing transaction otherwise.</li> <li><code>@Transactional(SUPPORTS)</code>: if a transaction was started, joins it ; otherwise works with no transaction.</li> <li><code>@Transactional(NOT_SUPPORTED)</code>: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</li> <li><code>@Transactional(NEVER)</code>: if a transaction was started, raises an exception ; otherwise works with no transaction.</li> </ul> <p>Creates a new <code>HeroResource.java</code> file in the same package with the following content:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.hibernate.orm.panache.PanacheEntity;\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\nimport java.util.Random;\n\n\n@Entity\npublic class Hero extends PanacheEntity {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    public String name;\n\n    public String otherName;\n\n    @NotNull\n    @Min(1)\n    public int level;\n    public String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n    public static Hero findRandom() {\n        Random random = new Random();\n        var count = count();\n        var index = random.nextInt((int) count);\n        return findAll().page(index, 1).firstResult();\n    }\n\n\n}\n</code></pre> <p>Notice that both methods that persist and update a hero, pass a <code>Hero</code> object as a parameter. Thanks to the Bean Validation\u2019s <code>@Valid</code> annotation, the <code>Hero</code> object will be checked to see if it\u2019s valid or not. It it\u2019s not, the transaction will be rollback-ed.</p>"},{"location":"transactions-orm/#configuring-the-datasource","title":"Configuring the Datasource","text":"<p>Our project now requires a connection to a PostgreSQL database. The main way of obtaining connections to a database is to use a datasource. In Quarkus, the out of the box datasource and connection pooling implementation is Agroal.footnote:[Agroal https://agroal.github.io]</p> <p>This is done in the <code>src/main/resources/application.properties</code> file.</p> <p>icon:hand-o-right[role=\u201dred\u201d, size=2x] [red big]#Call to action#</p> <p>Just add the following datasource configuration:</p>"},{"location":"transactions-orm/#heroresource-endpoint","title":"HeroResource Endpoint","text":"<p>The <code>HeroResource</code> Endpoint was bootstrapped with only one method <code>hello()</code>. We need to add extra methods that will allow CRUD operations on heroes.</p> <p>Here are the new methods to add to the <code>HeroResource</code> class:</p>"},{"location":"transactions-orm/#dependency-injection","title":"Dependency Injection","text":"<p>Dependency injection in Quarkus is based on ArC which is a CDI-based dependency injection solution tailored for Quarkus\u2019 architecture.footnote:[ArC https://github.com/quarkusio/quarkus/tree/master/independent-projects/arc] You can learn more about it in the Contexts and Dependency Injection guide.footnote:[Quarkus - Contexts and Dependency Injection https://quarkus.io/guides/cdi-reference.html]</p> <p>ArC comes as a dependency of <code>quarkus-resteasy</code> so you already have it handy. That\u2019s why you were able to use <code>@Inject</code> in the <code>HeroResource</code> to inject a reference to <code>HeroService</code>.</p>"},{"location":"transactions-orm/#adding-data","title":"Adding Data","text":"<p>To load some SQL statements when Hibernate ORM starts, add the following <code>import.sql</code> in the root of the <code>resources</code> directory. It contains SQL statements terminated by a semicolon. This is useful to have a data set ready for the tests or demos.</p> <p>Ok, but that\u2019s just a few entries. Download the SQL file {github-raw}/super-heroes/rest-hero/src/main/resources/import.sql[import.sql] and copy it under <code>src/main/resources</code>. Now, you have around 500 heroes that will be loaded in the database.</p> <p>If you didn\u2019t yet, start the application in dev mode:</p> <p><pre><code>$./mvnw quarkus:dev\n</code></pre> NOTE Consider copying the url mentioned by CRW</p> <p>Then, open your browser to $URL/api/heroes. You should see lots of heroes\u2026</p>"},{"location":"transactions-orm/#crud-tests-in-heroresourcetest","title":"CRUD Tests in HeroResourceTest","text":"<p>To test the <code>HeroResource</code> endpoint, we will be using a <code>QuarkusTestResource</code> that will fire a Postgres database and then test CRUD operations. The <code>QuarkusTestResource</code> is a test extension that can configure the environment before running the application but in our context, because of CRW, we will be using the database configured and running on OpenShift.</p> <p>We need to install in our <code>pom.xml</code> an extra dependency for data-binding functionality:</p> <p>Then, in <code>io.quarkus.workshop.superheroes.hero.HeroResourceTest</code>, you will add the following test methods to the <code>HeroResourceTest</code> class:</p> <ul> <li><code>shouldNotGetUnknownHero</code>: giving a random Hero identifier, the <code>HeroResource</code> endpoint should return a 204 (No content)</li> <li><code>shouldGetRandomHero</code>: checks that the <code>HeroResource</code> endpoint returns a random hero</li> <li><code>shouldNotAddInvalidItem</code>: passing an invalid <code>Hero</code> should fail when creating it (thanks to the <code>@Valid</code> annotation)</li> <li><code>shouldGetInitialItems</code>: checks that the <code>HeroResource</code> endpoint returns the list of heroes</li> <li><code>shouldAddAnItem</code>: checks that the <code>HeroResource</code> endpoint creates a valid <code>Hero</code></li> <li><code>shouldUpdateAnItem</code>: checks that the <code>HeroResource</code> endpoint updates a newly created <code>Hero</code></li> <li><code>shouldRemoveAnItem</code>: checks that the <code>HeroResource</code> endpoint deletes a hero from the database</li> </ul> <p>The code is as follow:</p> <p>Let\u2019s have a look to the 2 annotations used on the <code>HeroResourceTest</code> class. <code>@QuarkusTest</code> indicates that this test class is checking the behavior of a Quarkus application. The test framework starts the application before the test class and stops it once all the tests have been executed. The tests and the application runs in the same JVM, meaning that the test can be injected with application beans. This feature is very useful to test specific parts of the application. However in our case, we just execute HTTP requests to check the result.</p> <p>With this code written, execute the test using <code>./mvnw test</code>. The test should pass.</p>"},{"location":"trusted-apps/","title":"Red Hat Trusted Application Pipelines","text":""},{"location":"trusted-apps/#security-issue","title":"Security issue","text":"<p>guava-cve-issue</p>"},{"location":"villain-microservice/","title":"Villain microservice","text":""},{"location":"villain-microservice/#villain-microservice","title":"Villain microservice","text":""},{"location":"villain-microservice/#directory-structure","title":"Directory structure","text":""},{"location":"villain-microservice/#spring-compatibility-layer","title":"Spring compatibility layer","text":""},{"location":"villain-microservice/#running-testing-and-packaging","title":"Running, testing and packaging","text":""},{"location":"web-application/","title":"User Interface","text":""},{"location":"web-application/#the-web-application","title":"The Web Application","text":""},{"location":"requirements/dev-spaces/","title":"Software Requirements","text":"<p>First of all, make sure you have Web browser installed on your laptop and internet connectivity.</p> <p>Your environment is remote and can be accessed via DevSpaces through your local browser, you just need to sign up and configure some elements. Your environment includes also Red Hat\u2019s OpenShift Container Platform (OCP).</p> <p>The next section focuses on how to install and setup the needed software.</p>"},{"location":"requirements/dev-spaces/#red-hat-openshift-dev-spaces","title":"Red Hat OpenShift Dev Spaces","text":"<p>Red Hat OpenShift Dev Spaces  Workspaces is a collaborative Kubernetes-native development solution that delivers OpenShift workspaces and in-browser IDE for rapid cloud application development. </p>"},{"location":"requirements/dev-spaces/#dev-spaces-creation","title":"Dev Spaces creation","text":"<p>If everything goes well, you should have a Red Hat OpenShift Dev Spaces  Workspace with a <code>quarkus-workshop</code> folder ready to start to code:</p> <ul> <li>Finally, open a terminal from the Terminal menu \u2192 Open Terminal in     specific container \u2192 maven.</li> </ul>"},{"location":"requirements/dev-spaces/#command-line-utilities","title":"Command Line Utilities","text":"<p>Just make sure the following commands work on your CRW terminal</p> <pre><code>$ java -version\n$ mvn -version\n$ curl --version\n</code></pre>"},{"location":"requirements/openshift-cluster/","title":"OpenShift Container Platform","text":"<p>Your lab environment includes Red Hat\u2019s OpenShift Container Platform (OCP).</p> <p>Access to your OCP resources can be gained via both the <code>oc</code> CLI utility and the OCP web console.</p>"},{"location":"requirements/openshift-cluster/#overview","title":"Overview","text":"<p>The project we are going to develop will contain 3 microservices accessing to a PostgreSQL database.  We will make the databases to run in a OpenShift dedicated namespace.</p>"},{"location":"requirements/openshift-cluster/#openshift-namespaces","title":"OpenShift Namespaces","text":"<ol> <li>In the terminal of your Red Hat OpenShift Dev Spaces , authenticate into OpenShift as a non     cluster admin user (USERNAME) using the <code>oc</code> utility.</li> </ol> <p>You can get the command for authenticating from the OpenShift Web Console.</p> <pre><code>$ oc login\n</code></pre> <p>There are 2 namespaces (OpenShift projects) in your OpenShift cluster: The namespace for hosting your Red Hat OpenShift Dev Spaces environment is USERNAME-devspaces where <code>USERNAME</code> correspond to your specific username. The namespace for hosting databases and microservices is USERNAME-heroes.</p> <p>change the USERNAME with your own.</p>"},{"location":"requirements/openshift-cluster/#operators","title":"Operators","text":"<p>Your lab environment comes pre-installed with an OpenShift operator.</p> <p>PostgreSQL operator</p> <p>The PostgreSQL operator allows to package, install, configure and manage a PostgreSQL database within an OpenShift cluster.</p> <p>Congratulations! Your lab environment is now ready to use.</p>"}]}