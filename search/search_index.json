{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quarkus OpenShift + OpenShift AI Workshop","text":"<p>Welcome to the Quarkus OpenShift Workshop! This workshop is designed to help you get started with Quarkus and OpenShift and OpenShift.ai. You are going to learn about:</p> <ul> <li>Red Hat Developer Hub - the developer portal to initiate and maintain application development</li> <li>Red Hat OpenShift Dev Spaces - a container-based, in-browser development environment that facilitates development directly within the OpenShift ecosystem</li> <li>Quarkus - the Kubernetes Native Java stack tailored for Kubernetes and OpenShift</li> <li>Red Hat OpenShift - the Kubernetes platform for enterprise applications</li> <li>Red Hat Trusted Application Pipelines - the CI/CD pipeline enhancing security with automatic, integrated checks that catch vulnerabilities early in the software supply chain.</li> <li>Red Hat OpenShift AI - the AI/ML platform for OpenShift</li> </ul>"},{"location":"#the-system","title":"The system","text":"<p>In this workshop, we will be working on a very simple system composed of four services:</p> <ul> <li>a <code>hero service</code> - a simple REST service that returns superheroes. It uses a <code>PostgreSQL</code> database to store the heroes.</li> <li>a <code>villain service</code> - the <code>hero service</code> alter-ego storing super villains . It uses a <code>PostgreSQL</code> database to store the villains.</li> <li>a <code>fight service</code> - a service that orchestrates the fight between heroes and villains. It relies on AI to predict the outcome of the fight and generate a narration of the fight.</li> <li>a <code>fight ui</code> - a simple UI to interact with the <code>fight service</code>. This service is provided and already deployed in the OpenShift cluster.</li> </ul>"},{"location":"#the-development","title":"The development","text":"<p>All the development is done in codespaces, so you only need a recent web browser.  There is no need to install anything on your machine!</p> <p>You will get access to an OpenShift cluster where you will deploy the services that you will develop.</p>"},{"location":"#lets-get-started","title":"Let\u2019s get started!","text":"<p>Go to the overview page to start the workshop.</p>"},{"location":"conclusion-references/","title":"Conclusion","text":""},{"location":"conclusion-references/#conclusion-and-references","title":"Conclusion and References","text":"<p>This is the end of the Super Hero workshop. We hope you liked it, learnt a few things, and more importantly, will be able to take this knowledge back to your projects.</p> <p>This workshop started making sure your development environment was ready to develop the entire application.  If you find it was too short and need more details on Quarkus, Microservices, MicroProfile, Cloud Native, or GraalVM, check the Quarkus website for more references.</p> <p>You first installed an already coded React application in an instance of Quarkus. At this stage, the React application couldn\u2019t access the microservices because they were not deployed.</p> <p>Then, we focused on developing several isolated microservices.  Some written in pure JAX-RS (such as the Hero) others with Quarkus Spring compatibility layer (such as the Hero).  These microservices return data in JSON, validate data thanks to Bean Validation, store and retrieve data from a relational database with the help of JPA, Panache and JTA.</p> <p>Then, we made the microservices communicate with each other in HTTP thanks to REST Client.</p> <p>We\u2019ve also added some Artificial Intelligence. Thanks to Semantic Kernel, with a few lines of code, we allowed our Narration microservice to narrate the fight between a Super Hero and a Super Villain.</p> <p>Finally, we added the Micrometer metrics library to collect runtime, extension and application metrics and expose them as a Prometheus (OpenMetrics) endpoint.</p> <p>Then, came deployment time. With Argo CD it\u2019s very easy to deploy by just pushing the code to the GitLab repository.  From that, we used Red Hat Trusted Pipelines to detect a CVE and fix it.</p> <p>Remember that you can find all the code for this fascicle at https://github.com/cescoffier/quarkus-openshift-workshop. </p>"},{"location":"fight-microservice/","title":"Creating the Fight Microservice","text":"<p>Ok, let\u2019s develop another microservice.  We need a new REST API that invokes those two, gets one random hero and one random villain and makes them fight. Let\u2019s call it the Fight API.</p>"},{"location":"fight-microservice/#bootstrapping-the-hero-rest-endpoint","title":"Bootstrapping the Hero Rest Endpoint","text":"<p>Once logged in the Red Hat Developer Hub, please proceed with following steps:</p> <ul> <li>Navigate to the Create Option: in the left-hand menu of the RHDH, click on the \u201cCreate\u201d option.</li> </ul> <p></p> <ul> <li>Select the template: you\u2019ll see a list of available templates. Choose the <code>OpenCodeQuest - AI-Infused application with Quarkus</code> template from the list.</li> </ul> <p></p> <ul> <li>Select your cluster name, check the reference in the current url. The rest of the fields will be pre-filled by default.</li> </ul> <p></p> <ul> <li>Click Next button until a summary is shown</li> </ul> <p></p> <ul> <li> <p>Review the configuration. Then, click on <code>Create</code>.</p> </li> <li> <p>If everything went well, you should see the following successful page. Click on the <code>Open Component in Catalog</code>:</p> </li> </ul> <p></p> <ul> <li>Once in the fight-service component home page, you can launch the Dev Spaces opening by clicking the link OpenShift Dev Spaces (VS Code)</li> </ul> <p></p> <p>You should see the following page while the Dev Spaces is starting up:</p> <p></p>"},{"location":"fight-microservice/#the-fight-service","title":"The Fight Service","text":"<p>The Fight service is a Quarkus intelligent service.  Instead of randomly selecting a winner in the battle between heroes and villains, he can interact with a language model (LLM) and delegate the decision to it. Furthermore, this consultation will not only provide a winner but also a detailed description of how the fight unfolded.</p> <p>First, let\u2019s have a look at the big picture. When integrating an LLM into a Quarkus application,  you need to describe what you want the AI to do.  Unlike traditional code, you are going to explain the behavior of the AI using natural language. </p> <p>The following diagram illustrates the interactions between the Fight service and the LLM.</p> <p></p>"},{"location":"fight-microservice/#the-quarkus-langchain4j-extension","title":"The Quarkus-LangChain4j Extension","text":"<p>This extension is based on the LangChain4j library, which provides a common API to interact with LLMs.  The LangChain4j project is a Java re-implementation of the famous langchain library.</p> <p>Note that the extension is already present in the <code>pom.xml</code> file of your Fight service:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkiverse.langchain4j&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-langchain4j-openai&lt;/artifactId&gt;\n    &lt;version&gt;${quarkus-langchain4j.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"fight-microservice/#configuration","title":"Configuration","text":"<p>Configuring OpenAI models mandates an API key or API url among others.</p> <p>Copy the following configuration in your <code>fight-service/src/main/resources/application.properties</code> file:</p> <pre><code>quarkus.langchain4j.openai.base-url=https://granite-32-8b-instruct-llm.apps.cluster-5nb6z.5nb6z.sandbox1242.opentlc.com/v1\nquarkus.langchain4j.openai.chat-model.model-name=granite-32-8b-instruct\nquarkus.langchain4j.openai.api-key=${OPENAI_API_KEY:none}\nquarkus.langchain4j.openai.chat-model.temperature=1\nquarkus.langchain4j.log-requests=true\nquarkus.langchain4j.log-responses=true\nquarkus.langchain4j.openai.timeout=60s\n</code></pre> <p>They are self-explanatory, but you can check the documentation for more information.</p>"},{"location":"fight-microservice/#directory-structure","title":"Directory Structure","text":"<p>Notice that by bootstrapping the project with the specific <code>OpenCodeQuest - AI-Infused application with Quarkus</code> template, you get the following directory structure with a few Java classes already created and other artifacts:</p> <p></p> <p>It generates the following in the <code>fight-service</code> folder:</p> <ul> <li>the Maven structure with a <code>pom.xml</code></li> <li>an <code>io.quarkus.workshop.fight.FightResource.java</code> resource exposed on <code>/api/fights</code>.</li> <li>a straightforward java Record <code>Fight.java</code> that encapsulates the hero and villain inputs for a fight.</li> <li>the corresponding <code>Hero.java</code> and <code>Villain.java</code>.</li> <li>a java Record <code>FightResult.java</code>. Quarkus automatically creates an instance of <code>FightResult</code> from the LLM\u2019s JSON response.</li> <li>an intelligent service <code>FightSimulatorService.java</code>. This is where we will define the interaction with the LLM.</li> <li>the <code>application.properties</code> configuration file.</li> </ul>"},{"location":"fight-microservice/#defining-llm-interactions","title":"Defining LLM interactions","text":"<p>It\u2019s time to tell the LLM what we want to do.  The Quarkus LangChain4J extension provides a declarative way to describe LLM interactions.  We model the interaction using an interface annotated with <code>@RegisterAiService</code>.</p> <p>Edit the java interface <code>src/main/java/io/quarkus/workshop/fight/FightSimulatorService.java</code> and copy the following content:</p> <pre><code>package io.quarkus.workshop.fight;\n\nimport dev.langchain4j.service.UserMessage;\nimport io.quarkiverse.langchain4j.RegisterAiService;\nimport org.eclipse.microprofile.faulttolerance.Timeout;\n\nimport java.time.temporal.ChronoUnit;\n\n@RegisterAiService\npublic interface FightSimulatorService {\n\n\n    @UserMessage(\"\"\"\n            &lt;|system|&gt;\n            You are a simulation service that can simulate fights between heroes and villains.\n            Heroes and villains are represented with their name, level and superpowers.\n            Your goal is to simulate a fight and provide the winner and a short narration of the fight.\n            Include a part of randomness in the simulation to make it more interesting.\n            You must only use the information provided in the hero and villain objects to simulate the fight.\n            {response_schema}\n\n            &lt;|user|&gt;\n            Input: Hero[name=julien, level=2, powers=[python, javascript]]\n            Villain[name=clement, level=3, powers=[java, javascript]]\n\n            &lt;|assistant|&gt;\n            Output: {\"winner\": \"Clement\",\"narration\": \"Clement's intimate knowledge of Java and JavaScript allowed him to quickly adapt to the battle and use his powers to counter Julien's attempts to exploit his Python skills.\"}\n\n            &lt;|user|&gt;\n            Input: Hero[name=luke skywalker, level=100, powers=[the force, lightsaber]]\n            Villain[name=darth vader, level=90, powers=[the dark force, lightsaber]]\n\n            &lt;|assistant|&gt;\n            Output: {\"winner\": \"luke skywalker\",\"narration\": \"Luke Skywalker's mastery of the force and his lightsaber skills allowed him to defeat Darth Vader in a fierce battle. Despite Darth Vader's experience and power, Luke's determination and skill proved to be too much for him.\"}\n\n            &lt;|user|&gt;\n            Input: Hero[name=jar jar been, level=10, powers=[agility]]\n            Villain[name=super frog, level=20, powers=[super leap, speed]]\n\n            &lt;|assistant|&gt;\n            Output: {\"winner\": \"super frog\",\"narration\": \"Super frog super leaping ability allowed him to defeat jar jar been in a fierce battle. Despite jar jar been's experience and agility, super frog's skills proved to be too much for him.\"}\n\n            &lt;|user|&gt;\n            {hero}\n            {villain}\n\n            &lt;|assistant|&gt;\n            Output:\n            \"\"\")\n    @Timeout(value = 1, unit = ChronoUnit.MINUTES)\n    FightResult fight(Hero hero, Villain villain);\n\n}\n</code></pre> <p>The rest of the application would be able to use the LLM by injecting the <code>FightSimulatorService</code> interface and calling the methods.</p> <p>Speaking about methods, that\u2019s where the magic happens.  These methods accept parameters and are annotated with <code>@SystemMessage</code> and <code>@UserMessage</code> to define instructions directed to the LLM. You should describe what you want the LLM to do using natural language. </p> <p>The system defines the scope and initial instructions, serving as the first message sent to the LLM.  It delineates the AI service\u2019s role in the interaction.</p>"},{"location":"fight-microservice/#user-message-prompt","title":"User Message (Prompt)","text":"<p>Notice the presence of the <code>@UserMessage</code> annotation <code>FightSimulatorService</code>.  It defines primary instructions dispatched to the LLM.  It typically encompasses requests and the expected response format. As you can note, we are using a prompt template with following format.  This format is expected by the model.</p> <pre><code>&lt;|system|&gt;\nsystem prompt\n&lt;|user|&gt;\ncontent of the question\n&lt;|assistant|&gt;\nnew line for the model's answer\n</code></pre>"},{"location":"fight-microservice/#parameter-passing-and-referencing","title":"Parameter Passing and Referencing","text":"<p>AI methods can take parameters referenced in system and user messages using the {parameter} syntax. Note the <code>{hero}</code> and <code>{villain}</code> references.</p>"},{"location":"fight-microservice/#ai-method-return-type","title":"AI Method Return Type","text":"<p>The fight method returns a <code>FightResult</code>. The JSON response will be mapped to that object directly.</p>"},{"location":"fight-microservice/#fault-tolerance","title":"Fault Tolerance","text":"<p>The distributed nature of microservices makes external communication unreliable, increasing the need for application resiliency.  Quarkus addresses this by offering SmallRye Fault Tolerance, based on the MicroProfile Fault Tolerance specification.</p> <p>In the pom, you can see the corresponding smallrye dependencies: </p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-smallrye-fault-tolerance&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Then, in the code, notice the presence of the <code>@Timeout</code> annotation in the fight method</p> <p>If the LLM invocation is taking too long, the <code>@Timeout</code> annotation can stop it after 1 minute, preventing it from hanging indefinitely.</p>"},{"location":"fight-microservice/#the-fight-resource","title":"The Fight Resource","text":"<p>Now, let\u2019s take a look to the <code>fight-service/src/main/java/io/quarkus/workshop/fight/FightResource.java</code>. This is a JAX-RS resource just like the Hero endpoint where the FightSimulatorService is injected. Then the intelligent <code>fight</code> method is called from the exposed <code>fight</code> method. </p>"},{"location":"fight-microservice/#start-the-fight-service-in-dev-mode","title":"Start the Fight service in dev mode","text":"<p>We are now ready to run our application.</p> <p>Open a Terminal and run one of the following commands:</p> <p><code>./mvnw quarkus:dev</code></p> <p>or</p> <p><code>quarkus dev</code></p>"},{"location":"fight-microservice/#verify-the-fight-service","title":"Verify the Fight service","text":"<p>For verifying the Fight service is up and running, open the Developer Console by navigating to the $FIGHT_URL/q/dev-ui</p> <p>Ou by clicking the <code>Open in New Tab</code> button when a pop up will be shown:</p> <p></p>"},{"location":"fight-microservice/#deploy-the-fight-microservice","title":"Deploy the Fight microservice","text":"<p>To deploy the Fight service, remember to perform a commit&amp;push of the code. You can get some help here</p> <p>Then, you can tag and release your code in GitLab to promote in preprod and prod.</p> <p>Verify that everything works by navigating to the fight-ui dev url and launch a few fights between heroes and villains!</p> <p></p>"},{"location":"fight-microservice/#observability","title":"Observability","text":"<p>Observability is built into services created via <code>@RegisterAiService</code> and metrics collection is enabled when quarkus-micrometer is part of the application. Micrometer defines an API for basic meter types, like counters, gauges, timers, and distribution summaries, along with a MeterRegistry API that generalizes metrics collection and propagation for different backend monitoring systems.</p> <p>Be aware that the <code>micrometer-registry-prometheus</code> extension is already present in your <code>pom.xml</code> file.</p>"},{"location":"fight-microservice/#metrics","title":"Metrics","text":"<p>Each AI method is automatically timed and the timer data is available using the <code>langchain4j.aiservices.$interface_name.$method_name</code> template for the name.</p>"},{"location":"fight-microservice/#create-your-own-metrics","title":"Create your own metrics","text":"<p>Metrics data is used in the aggregate to observe how data changes over time.  Metrics are already in place. The java class <code>fight-service/src/main/java/io/quarkus/workshop/fight/FightMetricPublisher.java</code> contains a CDI bean as follows:</p> <pre><code>package io.quarkus.workshop.fight;\n\nimport io.micrometer.core.instrument.Counter;\nimport io.micrometer.core.instrument.MeterRegistry;\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@ApplicationScoped\npublic class FightMetricPublisher {\n\n    private final Counter heroVictories;\n    private final Counter villainVictories;\n\n    FightMetricPublisher(MeterRegistry registry) {\n        heroVictories = registry.counter(\"fights\", \"won-by\", \"hero\");\n        villainVictories = registry.counter(\"fights\", \"won-by\", \"villain\");\n    }\n\n    public void publishFight(Fight fight, FightResult result) {\n        if (result.winner().equalsIgnoreCase(fight.hero().name())) {\n            heroVictories.increment();\n        } else {\n            villainVictories.increment();\n        }\n    }\n}\n</code></pre> <p>We can see two counters there. Counters measure values that only increase. The counter is created directly on the MeterRegistry.</p> <p><code>fights</code> is the counter name and <code>won-by</code> is a tag with two possible values: <code>hero</code>or <code>villain</code>. This counters will tell us who is winning more times, if heroes or villains. </p> <p>Finally, check how the <code>FightMetricPublisher</code> is injected in the <code>FightResource</code> and called each time that a fight happen.</p>"},{"location":"fight-microservice/#verify-metrics","title":"Verify metrics","text":"<p>The Micrometer Prometheus MeterRegistry extension creates an endpoint we can use to observe collected metrics, this endpoint is exposed in $fight-service/q/metrics path. </p> <p>Let\u2019s take a look at the metrics that have been collected:</p> <ul> <li>Click on Topology tab of the fight service in Red Hat Developer Hub</li> </ul> <p></p> <ul> <li>Click the arrow</li> <li>A new tab should open.</li> <li>Add the <code>/q/metrics</code> path to the url opened in previous step. You should see the metrics. Besides some automatically generated metrics like the <code>http_server_requests_seconds_count</code> or <code>http_server_requests_seconds_sum</code>, you should also see the custom metrics counting the fights calls and how many times won the heroes and the villains:</li> </ul> <p></p>"},{"location":"fight-microservice/#stop-your-devspaces-workspace","title":"Stop your DevSpaces Workspace","text":"<p>As you now have fully deployed your microservice, you do not need anymore the DevSpaces workspace so let\u2019s just stop it to preserve resources.</p> <p>Click the grey button \u201d&gt;&lt;\u201d on the bottom left of DevSpaces IDE</p> <p></p> <p>Then Click \u201cDev Spaces : Stop Workspace</p> <p></p>"},{"location":"from-git-to-openshif/","title":"From Git to OpenShift","text":""},{"location":"from-git-to-openshif/#deploying-to-openshift-cluster","title":"Deploying to OpenShift cluster.","text":"<p>This approach will be followed for all the microservices. With ArgoCD, deploying to the OpenShift cluster is as simple as committing and pushing your changes to the GitLab repository.  To do this, follow these steps:</p> <ul> <li>In Dev Spaces, go to the source control view.</li> <li>Enter your commit message</li> <li>Click the Commit button.</li> </ul> <p></p> <ul> <li>After committing, click the Sync Changes button to push your changes.</li> </ul> <p></p> <p>This action will trigger a pipeline, which you can monitor in the CI tab of the RHDH. Once the pipeline completes successfully, you will see the corresponding pod in the Topology tab.  From there, you can access your hero microservice by clicking on the pod.</p>"},{"location":"from-git-to-openshif/#exploring-the-pipeline","title":"Exploring the pipeline","text":"<p>Let\u2019s switch to the Developer Hub console, in your hero component.</p> <p>Click the CI tab</p> <p>Once you commited your code, an OpenShift pipeline has been automaticaly triggered. This pipeline was created automaticaly for your project when you instanciated the template.</p> <p></p> <p>As you can see, a lot of steps are now running so let\u2019s explore a little.</p> <p>The first step in the pipeline is a simple git clone. The next step is basically a mvn package and then running of Sonarqube scan-source for static analysis. All pretty standard for CI pipelines. Get the code, compile/build the code, run some scans.</p>"},{"location":"from-git-to-openshif/#build-sign-image","title":"build-sign-image","text":"<p>It is the build-sign-image where things get super interesting.</p> <p></p> <p>The template is leveraging Tekton Chains, a Kubernetes Custom Resource Definition (CRD) controller, that nicely augments the supply chain security within OpenShift Pipelines. This tool\u2019s capacity to automatically sign task runs, and its adoption of advanced attestation formats like in-toto and SLA provenance, bring a higher degree of trust and verification to our processes. Tekton Chains works like an independent observer within the cluster, it signs, attests and stores additional artifacts as OCI images alongside with your container image.</p> <p>Also, you can see we are using this step to automatically create a SBOM (Software Bill Of Materials) which is a kind of ingredients list for your software.</p> <p>More information regarding the pipeline can be seen in next section Trusted Application Pipeline</p>"},{"location":"from-git-to-openshif/#dev-deployment","title":"Dev Deployment","text":"<p>As a developer, I want to see my handy work, did my application really deploy to the dev environment ?</p> <p>You can check that your newly built application has been automatically sync using OpenShift GitOps (ArgoCD) if you switch to the Overview Tab.</p> <p></p> <p>Click on Topology</p> <p>This should look familiar to you if you regularly use the topology view from OpenShift. </p> <p>Note: pre-prod and prod have NOT yet deployed</p> <p>Click the arrow. This will open a new tab on your browser showing your deployed hero-service !</p> <p>Oops!! A <code>Resource Not Found</code> may be shown. </p> <p></p> <p>You can add <code>/api/heroes/hello</code> , <code>/api/heroes/random</code> or <code>/api/heroes</code> to the URL in you browser to attack the good endpoints and check your work</p> <p>Note that during the deployment with OpenShift GitOps, we also deployed automatically the Database containing all the superheroes using the EDB Cluster CRD that automaticaly manage our database.</p> <p>Verify that the fight-ui dev environment is now able to retrieve the characters</p>"},{"location":"from-git-to-openshif/#promote-to-pre-prod","title":"Promote to Pre-Prod","text":"<p>First access the GitLab UI, there is a convenient link on the Overview tab</p> <p></p> <p>Click on Tags</p> <p></p> <p>New Tag</p> <p></p> <p>Give the tag a name like v1.0</p> <p>and click Create tag</p> <p></p> <p>Back to the portal and the CI tab to see the promotion pipeline in action</p> <p></p> <p>This pipeline has a special task called verify-enterprise-contract</p> <p>Enterprise Contract (EC) is a special CLI that compliments Sigstore\u2019s cosign. If you remember the build-sign-image task that produced and stored the .sig and .att artifacts into the container registry, EC evaluates that signature and attestation. EC is based on the rego policy language from Open Policy Agent and allows you to create custom rules to review cosign attest attestations. By default, EC works with the SLSA provence attestation coming out of Tekton Chains.</p> <p></p> <p>Enterprise Contract, as part of this promotion pipeline, is verifing that the container image did in fact come from the corporate standard/approved build system. In other words, this container image was not built on some random person\u2019s laptop, it was built in the secure build system. The .att, .sbom and .sig are stored alongside the container image and a tool like skopeo can be used to move all items together.</p> <p>https://enterprisecontract.dev/</p> <p>The Hitchhiker\u2019s Guide is particularly good way to get started understanding EC.</p> <p>Once the release pipeline has completed, you can see your application has been promoted to pre-prod and is available via the Topology plug-in.</p> <p></p>"},{"location":"from-git-to-openshif/#promote-to-prod","title":"Promote to Prod","text":"<p>To promote to Production use the Create Release feature of the GitLab UI.</p> <p></p> <p>Give the release a title and click the Create release button</p> <p></p> <p>Another release pipeline will be triggered and if the Enterprise Contract passes then the container image will be promoted production.</p> <p></p> <p></p> <p>Promotion to preprod and prod should be done for every services (villains/fight)</p>"},{"location":"from-git-to-openshif/#stop-your-devspaces-workspace","title":"Stop your DevSpaces Workspace","text":"<p>As you now have fully deployed your microservice, you do not need anymore the DevSpaces workspace so let\u2019s just stop it to preserve resources.</p> <p>Click the grey button \u201d&gt;&lt;\u201d on the bottom left of DevSpaces IDE</p> <p></p> <p>Then Click \u201cDev Spaces : Stop Workspace</p> <p></p>"},{"location":"hero-microservice/","title":"Creating the Hero Microservice","text":""},{"location":"hero-microservice/#bootstrapping-the-hero-rest-endpoint","title":"Bootstrapping the Hero Rest Endpoint","text":"<p>Once logged in the Red Hat Developer Hub, please proceed with following steps:</p> <ul> <li>Navigate to the Create Option: in the left-hand menu of the RHDH, click on the \u201cCreate\u201d option.</li> </ul> <p></p> <ul> <li>Select the template: you\u2019ll see a list of available templates. Choose the <code>OpenCodeQuest - Quarkus CRUD microservice</code> template from the list.</li> </ul> <p></p> <ul> <li>Select your cluster name, check the reference in the current url. The rest of the fields will be pre-filled by default.</li> </ul> <p></p> <ul> <li>Click Next button until a summary is shown</li> </ul> <p></p> <ul> <li> <p>Review the configuration. Then, click on <code>Create</code>.</p> </li> <li> <p>If everything went well, you should see the following successful page. Click on the <code>Open Component in Catalog</code>:</p> </li> </ul> <p></p> <ul> <li>Once in the hero-service component home page, you can launch the Dev Spaces opening by clicking the link OpenShift Dev Spaces (VS Code)</li> </ul> <p></p> <p>You may be asked to authenticate again. Please, proceed.  You should see the following page while the Dev Spaces is starting up:</p> <p></p>"},{"location":"hero-microservice/#the-hero-service","title":"The Hero Service","text":"<p>The Super Heroes microservice stores super-heroes, with their names, powers, and so on. We need to expose a REST API allowing CRUD operations on super heroes. This microservice is a classical microservice. It uses HTTP to expose a REST API, and it internally stores data into a database.</p> <p>This service will be used by the fight microservice.</p> <p></p>"},{"location":"hero-microservice/#directory-structure","title":"Directory Structure","text":"<p>Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:</p> <p></p> <p>It generates the following in the <code>hero-service</code> folder:</p> <ul> <li>the Maven structure with a <code>pom.xml</code></li> <li>an <code>io.quarkus.workshop.hero.HeroResource</code> resource exposed on <code>/api/heroes</code></li> <li>an associated unit test <code>HeroResourceTest</code></li> <li>the landing page <code>index.html</code> that is accessible after starting the application</li> <li>the <code>application.properties</code> configuration file</li> </ul> <p>Look at the <code>pom.xml</code>. You will find here the import of the Quarkus BOM (bill of materials), allowing you to omit the version on the different Quarkus dependencies. In addition, you can see the <code>quarkus-maven-plugin</code>, responsible for the packaging of the application and also providing the development mode support.</p> <p>Regarding the dependencies section, you can see the extension allowing the development of REST applications.</p>"},{"location":"hero-microservice/#the-jax-rs-resource","title":"The JAX-RS Resource","text":"<p>During the project creation, the <code>hero-service/src/main/java/io/quarkus/workshop/hero/HeroResource.java</code> file has been created with the following content:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.logging.Log;\nimport io.smallrye.common.annotation.RunOnVirtualThread;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.eclipse.microprofile.openapi.annotations.media.Content;\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\nimport org.eclipse.microprofile.openapi.annotations.responses.APIResponse;\nimport org.eclipse.microprofile.openapi.annotations.Operation;\nimport org.jboss.resteasy.reactive.RestResponse;\n\n\n\nimport java.net.URI;\nimport java.util.List;\n\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\n\n@Path(\"/api/heroes\")\n@RunOnVirtualThread\npublic class HeroResource {\n\n    @GET\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello from Quarkus REST\";\n    }\n\n}\n</code></pre> <p>It\u2019s a very simple REST endpoint, returning \u201chello\u201d to HTTP GET requests to <code>/api/heroes</code>.</p>"},{"location":"hero-microservice/#running-the-application","title":"Running the Application","text":"<p>We are now ready to run our application.</p> <p>You can use either the <code>quarkus</code> cli or <code>Apache Maven</code> command-line interface in a Terminal.</p> <p>Open a Terminal by clicking on the hamburger menu (three horizontal lines) located in the upper-left corner of the screen. Navigate to Terminal and select New Terminal from the dropdown menu.</p> <p>Then, run one of the following commands: </p> <p><code>./mvnw quarkus:dev</code></p> <p>or </p> <p><code>quarkus dev</code></p> <pre><code>$  quarkus dev\n[INFO] Scanning for projects...\n[INFO] \n[INFO] ------------------&lt; com.redhat.workshop:hero-service &gt;------------------\n[INFO] Building hero-service 1.0-SNAPSHOT\n[INFO]   from pom.xml\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO] \n[INFO] --- quarkus:3.13.2:dev (default-cli) @ hero-service ---\n[INFO] Invoking resources:3.3.1:resources (default-resources) @ hero-service\n[INFO] Copying 2 resources from src/main/resources to target/classes\n[INFO] Invoking quarkus:3.13.2:generate-code (default) @ hero-service\n[INFO] Invoking compiler:3.13.0:compile (default-compile) @ hero-service\n[INFO] Nothing to compile - all classes are up to date.\n[INFO] Invoking resources:3.3.1:testResources (default-testResources) @ hero-service\n[INFO] skip non existing resourceDirectory /projects/hero/src/test/resources\n[INFO] Invoking quarkus:3.13.2:generate-code-tests (default) @ hero-service\n[INFO] Invoking compiler:3.13.0:testCompile (default-testCompile) @ hero-service\n[INFO] Nothing to compile - all classes are up to date.\n\n----------------------------\n--- Help improve Quarkus ---\n----------------------------\n* Learn more: https://quarkus.io/usage/\n* Do you agree to contribute anonymous build time data to the Quarkus community? (y/n and enter) \n[info] [Quarkus build analytics] Didn't receive the user's answer after 10 seconds. The question will be asked again next time.\n\nListening for transport dt_socket at address: 5005\n2024-08-28 11:39:46,023 INFO  [io.qua.dat.dep.dev.DevServicesDatasourceProcessor] (build-21) Dev Services for default datasource (postgresql) started - container ID is b64fe935733f\n2024-08-28 11:39:46,026 INFO  [io.qua.hib.orm.dep.dev.HibernateOrmDevServicesProcessor] (build-34) Setting quarkus.hibernate-orm.database.generation=drop-and-create to initialize Dev Services managed database\n__  ____  __  _____   ___  __ ____  ______ \n --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/ \n -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\\ \\   \n--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/   \n2024-08-28 11:39:46,603 WARN  [io.qua.config] (Quarkus Main Thread) Unrecognized configuration key \"quarkus.smallrye-openapi.store-schema-directory\" was provided; it will be ignored; verify that the dependency extension for this configuration is set or that you did not make a typo\n2024-08-28 11:39:48,103 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) SQL Warning Code: 0, SQLState: 00000\n2024-08-28 11:39:48,105 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) table \"myentity\" does not exist, skipping\n2024-08-28 11:39:48,106 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) SQL Warning Code: 0, SQLState: 00000\n2024-08-28 11:39:48,106 WARN  [org.hib.eng.jdb.spi.SqlExceptionHelper] (JPA Startup Thread) sequence \"myentity_seq\" does not exist, skipping\n2024-08-28 11:39:48,316 INFO  [io.quarkus] (Quarkus Main Thread) hero-service 1.0-SNAPSHOT on JVM (powered by Quarkus 3.13.2) started in 7.445s. Listening on: http://0.0.0.0:8080\n2024-08-28 11:39:48,317 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.\n2024-08-28 11:39:48,317 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, hibernate-validator, jdbc-postgresql, micrometer, narayana-jta, rest, rest-jackson, smallrye-context-propagation, smallrye-health, vertx]\n\n--\nTests paused\nPress [e] to edit command line args (currently ''), [r] to resume testing, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre> <p>At some point, a pop up asking for opening the Quarkus dev will be shown:</p> <p></p> <p>Click on the <code>Open in New Tab</code> button.</p> <p>You can now check that the endpoint returns <code>Hello from Quarkus REST</code> as expected.</p> <p>Open a new Terminal and run the following command</p> <pre><code>curl http://localhost:8080/api/heroes/hello\n</code></pre>"},{"location":"hero-microservice/#development-mode","title":"Development Mode","text":"<p><code>mvn quarkus:dev</code> or <code>quarkus dev</code> runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and invoke a REST endpoint (i.e. cUrl command or refresh your browser), these changes will automatically take effect. If there are any issues with compilation an error page will let you know.</p> <p>The development mode also allows debugging and listens for a debugger on port 5005.</p>"},{"location":"hero-microservice/#dev-ui","title":"Dev UI","text":"<p>Quarkus ships with a Developer UI, which is available in dev mode at /q/dev-ui path by default. It will show you something like this:</p> <p></p> <p>It allows you to:</p> <ul> <li>quickly visualize all the extensions currently loaded</li> <li>view extension statuses and go directly to extension documentation</li> <li>view and change Configuration</li> <li>manage and visualize Continuous Testing</li> <li>view Dev Services information</li> <li>view the Build information</li> <li>view and stream various logs</li> </ul> <p>Each extension used in the application will be listed</p> <p>Open the Developer Console by navigating to the $HERO_URL/q/dev-ui </p>"},{"location":"hero-microservice/#testing-the-application","title":"Testing the Application","text":"<p>So far so good, but wouldn\u2019t it be better with a few tests, just in case?</p> <p>In the generated <code>pom.xml</code> file, you can see 2 test dependencies:</p> <p><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;\n    &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> The generated project contains a simple test in <code>hero-service/src/test/java/io/quarkus/workshop/hero/HeroResourceTest.java</code>.</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.NOT_FOUND;\nimport static jakarta.ws.rs.core.Response.Status.NO_CONTENT;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass HeroResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n                .when()\n                .get(\"/api/heroes/hello\")\n                .then()\n                .statusCode(200)\n                .body(is(\"Hello from Quarkus REST\"));\n    }\n\n}\n</code></pre> <p>By using the <code>QuarkusTest</code> runner, the <code>HeroResourceTest</code> class instructs JUnit to start the application before the tests. Then, the <code>testHelloEndpoint</code> method checks the HTTP response status code and content.</p> <p>You can running the tests with <code>./mvnw test</code> in a new Terminal.</p>"},{"location":"hero-microservice/#continuous-testing","title":"Continuous testing","text":"<p>Quarkus supports continuous testing, where tests run immediately after code changes have been saved.  This allows you to get instant feedback on your code changes.</p> <p>When you start Quarkus in dev mode, down the bottom of the screen you should see the following:</p> <p><pre><code>Tests paused, press [r] to resume, [h] for more options&gt;\n</code></pre> Press `r and the tests will start running. You should see the status change down the bottom of the screen as they are running, and it should finish with:</p> <pre><code>All 1 test is passing (0 skipped), 1 test was run in 8053ms. Tests completed at 12:11:25.\nPress [e] to edit command line args (currently ''), [r] to re-run, [o] Toggle test output, [:] for the terminal, [h] for more options&gt;\n</code></pre>"},{"location":"open-api/","title":"Open API","text":"<p>By default, a Quarkus application exposes its API description through an OpenAPI specification. Quarkus also lets you test it via a user-friendly UI named Swagger UI.</p>"},{"location":"open-api/#open-api-dependency","title":"Open API Dependency","text":"<p>Quarkus proposes a smallrye-openapi extension compliant with the Eclipse MicroProfile OpenAPI specification in order to generate your API OpenAPI specification.</p> <p>The OpenAPI dependency is already present in the <code>pom.xml</code> of the hero-service. Check it out:</p> <p><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-smallrye-openapi&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> Now, you can curl the openapi endpoint and get the API description of the HeroResource.</p> <p>In a Terminal, run the following command</p> <pre><code>curl http://localhost:8080/q/openapi\n</code></pre> <p>You should have something like:</p> <pre><code>---\nopenapi: 3.0.3\ninfo:\n  title: hero-service API\n  version: 1.0.0-SNAPSHOT\npaths:\n  /api/heroes:\n    get:\n      tags:\n      - Hero Resource\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: \"#/components/schemas/Hero\"\n    put:\n      tags:\n      - Hero Resource\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/Hero\"\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Hero\"\n    post:\n      tags:\n      - Hero Resource\n      requestBody:\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/Hero\"\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                format: uri\n                type: string\n  /api/heroes/hello:\n    get:\n      tags:\n      - Hero Resource\n      responses:\n        \"200\":\n          description: OK\n          content:\n            text/plain:\n              schema:\n                type: string\n  /api/heroes/random:\n    get:\n      tags:\n      - Hero Resource\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Hero\"\n  /api/heroes/{id}:\n    get:\n      tags:\n      - Hero Resource\n      parameters:\n      - name: id\n        in: path\n        required: true\n        schema:\n          format: int64\n          type: integer\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/Hero\"\n    delete:\n      tags:\n      - Hero Resource\n      parameters:\n      - name: id\n        in: path\n        required: true\n        schema:\n          format: int64\n          type: integer\n      responses:\n        \"204\":\n          description: No Content\ncomponents:\n  schemas:\n    Hero:\n      required:\n      - name\n      - level\n      type: object\n      properties:\n        id:\n          format: int64\n          type: integer\n        name:\n          maxLength: 50\n          minLength: 3\n          type: string\n        otherName:\n          type: string\n        level:\n          format: int32\n          minimum: 1\n          type: integer\n        picture:\n          type: string\n        powers:\n          type: string\n</code></pre>"},{"location":"open-api/#swagger-ui","title":"Swagger UI","text":"<p>When building APIs, developers want to test them quickly.  Swagger UI is a great tool permitting to visualize and interact with your APIs. The UI is automatically generated from your OpenAPI specification.  The Quarkus smallrye-openapi extension comes with a swagger-ui extension embedding a properly configured Swagger UI page. </p> <p>The Swagger UI is accessible from the Red Hat Developer Hub, in the hero component dashboard, just click on the <code>Api</code> tab:</p> <p></p> <p>Then, select the <code>$USER-hero</code> provided API</p> <p></p> <p>And, finally, click in the <code>Definition</code> tab </p> <p></p> <p>Here you can see the Swagger UI for Heroes API.</p> <p>By default, Swagger UI is also accessible at $URL/q/swagger-ui endpoint.  So, once your application is started in dev mode, you can navigate with a browser to $URL/q/swagger-ui and play with your API.</p> <p></p> <p>Ok, now, before continuing with the workshop\u2026</p> <ul> <li> <p> Stop the dev mode </p> <p>Please stop the hero-service launched in dev mode clicking <code>Ctrl + C</code> otherwise you will get a conflict port error.</p> </li> </ul>"},{"location":"overview/","title":"Overview","text":"<p>This workshop illustrates how to build intelligent applications using:</p> <ul> <li>Red Hat OpenShift</li> <li>Red Hat OpenShift AI/ML Services</li> <li>Quarkus</li> <li>Red Hat Developer Hub</li> <li>Red Hat Trusted Application Pipelines</li> <li>Red Hat OpenShift Dev Spaces</li> </ul> <p>This workshop covers both the development and deployment of such applications on OpenShift as well as the integration with OpenShift AI/ML Services.</p> <p>It proposes a platform engineering approach to the development of intelligent applications. Thus, the code is developed in CodeSpaces and the deployment is done using Trusted Application Pipelines. The different application components run in OpenShift.</p>"},{"location":"overview/#the-application","title":"The application","text":"<p>In this workshop you will develop an application that allows super-heroes to fight against villains. </p> <p></p> <p>Being a workshop about microservices, you will be developing several microservices communicating synchronously via REST API endpoints:</p> <ul> <li><code>frontend</code>: a web application that allows users to pick up a random super-hero, a random villain and makes them fight. The Super Hero UI invokes the Hero, Villain and Fight REST endpoints.</li> <li><code>hero-service</code>: a Quarkus microservice that provides CRUD operations on Heroes which are stored in a PostgresSQL database.</li> <li><code>villain-service</code>: the counterpart of the hero service, for villains.</li> <li><code>fight-service</code>: a microservice that simulates a fight between a hero and a villain. The simulation is done using a Large Language Model (LLM) that is deployed on OpenShift AI/ML Services. The result also includes a short narration of the fight:</li> </ul> <p></p>"},{"location":"overview/#the-architecture","title":"The architecture","text":"<p>Hero and Villain services</p> <p>The <code>hero-service</code> and <code>villain-service</code> are very similar, yet they use different development models. While both are Quarkus applications, the hero service uses the idiomatic Quarkus development model, while the villain service uses the Spring compatibility support from Quarkus.</p>"},{"location":"packaging-app/","title":"Packaging app","text":""},{"location":"packaging-app/#packaging-and-running-the-application","title":"Packaging and Running the Application","text":"<p>If you don\u2019t stopped the hero-service dev mode, please stop it.</p> <p>The application is packaged running <code>./mvnw package</code> or <code>quarkus build</code> in a Terminal. It produces 2 jar files in <code>/target</code>:</p> <ul> <li><code>rest-hero-1.0-SNAPSHOT.jar</code>: containing just the classes and resources of the projects, it\u2019s the regular artifact produced by the Maven build;</li> <li><code>quarkus-app/quarkus-run.jar</code>: being an executable jar.   Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the <code>target/quarkus-app/lib</code> directory.</li> </ul> <p>The application is now runnable from a terminal by running the following command:</p> <pre><code>java -jar target/quarkus-app/quarkus-run.jar\n</code></pre> <p>Now: </p> <ul> <li> <p> Stop the hero-service </p> <p>Please stop the hero-service.</p> </li> </ul>"},{"location":"requirements/","title":"Software Requirements","text":"<p>First of all, make sure you that have a web browser installed on your laptop and proper internet connectivity.</p> <p>Your environment is remote and can be accessed via Red Hat Developer Hub through your local browser: you just need to navigate to the url available on the physical card you have been given and sign in using the credentials.</p> <p>Your environment includes:</p> <ul> <li>Dev Spaces: an in-browser IDE for rapid cloud application development. This where you are going to write Java code.</li> <li>OpenShift Container Platform: an OpenShift cluster where you are going to deploy the Quarkus microservices.</li> </ul>"},{"location":"requirements/#access-to-red-hat-developer-hub-rhdh","title":"Access to Red Hat Developer Hub (RHDH)","text":"<p>Go to the RHDH url. A login page should be shown.</p> <p></p> <p>Introduce the login and password provided and select GitLab as Sign In mode. You should be redirected to the GitLab authentication page.</p> <p></p> <p>Enter the login and password provided. The Red Hat Developer Hub home page should be displayed.</p> <p></p> <p>This page shows an overview of your environment with all available tools.</p>"},{"location":"transactions-orm/","title":"Transactions and ORM","text":"<p>The Hero API\u2019s role is to allow CRUD operations on Super Heroes. In this module we will create a Hero entity and persist/update/delete/retrieve it from a Postgres database in a transactional way.</p>"},{"location":"transactions-orm/#database-dependencies","title":"Database dependencies","text":"<p>This microservice:</p> <ul> <li>interacts with a PostGreSQL database - so it needs a driver</li> <li>uses Hibernate with Panache - so need the dependency on it</li> <li>validates payloads and entities - so need a validator</li> <li>consumes and produces JSON - so we need a mapper</li> </ul> <p>Hibernate ORM is the de-facto JPA implementation and offers you the full breadth of an Object Relational Mapper. It makes complex mappings possible, but it does not make simple and common mappings trivial. Hibernate ORM with Panache focuses on making your entities trivial and fun to write in Quarkus.</p> <p>Because JPA and Bean Validation work well together, we will use Bean Validation to constrain our business model.</p> <p>All the needed dependencies to access the database are already in the <code>pom.xml</code> file. </p> <p>Check that you have the following:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;\n    &lt;artifactId&gt;quarkus-rest-jackson&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"transactions-orm/#hero-entity","title":"Hero Entity","text":"<p>At this point we need an Entity class. There is already a <code>Hero.java</code> file under <code>src/main/java/io/quarkus/workshop/hero</code> so you don\u2019t need to create it. However this file is empty. To define a Panache entity, simply extend <code>PanacheEntity</code>, annotate it with <code>@Entity</code> and add your columns as public fields (no need to have getters and setters).</p> <p>Edit the <code>Hero.java</code> file under <code>src/main/java/io/quarkus/workshop/hero</code> and copy the following content:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.hibernate.orm.panache.PanacheEntity;\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\nimport java.util.Random;\n\n\n@Entity\npublic class Hero extends PanacheEntity {\n\n    @NotNull\n    @Size(min = 3, max = 50)\n    public String name;\n\n    public String otherName;\n\n    @NotNull\n    @Min(1)\n    public int level;\n    public String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n    @Override\n    public String toString() {\n        return \"Hero{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", otherName='\" + otherName + '\\'' +\n                \", level=\" + level +\n                \", picture='\" + picture + '\\'' +\n                \", powers='\" + powers + '\\'' +\n                '}';\n    }\n\n}\n</code></pre> <p>Notice that you can put all your JPA column annotations and Bean Validation constraint annotations on the public fields.</p>"},{"location":"transactions-orm/#adding-operations","title":"Adding Operations","text":"<p>For our workshop we need returning a random hero. For that it\u2019s just a matter to add the following method to our <code>Hero.java</code> entity:</p> <pre><code>public static Hero findRandom() {\n    Random random = new Random();\n    var count = count();\n    var index = random.nextInt((int) count);\n    return findAll().page(index, 1).firstResult();\n}\n</code></pre> <ul> <li> <p> Import </p> <p>You would need to add the following import statement if not done automatically by your IDE <code>import java.util.Random;</code></p> </li> </ul>"},{"location":"transactions-orm/#configuring-hibernate","title":"Configuring Hibernate","text":"<p>As Quarkus supports the automatic provisioning of unconfigured services in development and test mode, we don\u2019t need at the moment to configure anything regarding the database access.  Quarkus will automatically start a Postgresql service and wire up your application to use this service. </p> <p>Quarkus development mode is great for apps that combine front-end, services, and database access. By using quarkus.hibernate-orm.database.generation=drop-and-create with import.sql, any changes to your entities automatically recreate the database schema and repopulate data. This setup works perfectly with Quarkus live reload, instantly applying changes without restarting the app.</p> <p>For that, make sure to have the following configuration in your <code>application.properties</code> (located in <code>src/main/resources</code>):</p> <pre><code>%dev.quarkus.hibernate-orm.database.generation=drop-and-create\n</code></pre>"},{"location":"transactions-orm/#adding-data","title":"Adding Data","text":"<p>To load some data when Hibernate ORM starts, run the following command on a Terminal:</p> <pre><code>curl https://raw.githubusercontent.com/cescoffier/quarkus-openshift-workshop/03d5a943c0948bc53c598b6ee78a71e50ef77cee/hero-service/src/main/resources/import.sql -fL -o src/main/resources/import.sql\n</code></pre> <p>It will download the specified file and copy the content in your <code>/src/resources/import.sql</code> file. Now, you have around 500 heroes that will be loaded in the database.</p>"},{"location":"transactions-orm/#heroresource-endpoint","title":"HeroResource Endpoint","text":"<p>The <code>HeroResource</code> Endpoint was bootstrapped with only one method <code>hello()</code>. We need to add extra methods that will allow CRUD operations on heroes.</p>"},{"location":"transactions-orm/#making-heroresource-transactional","title":"Making HeroResource Transactional","text":"<p>To manipulate the <code>Hero</code> entity we need make <code>HeroResource</code> transactional. The idea is to wrap methods modifying the database (e.g. <code>entity.persist()</code>) within a transaction. Marking a CDI bean method <code>@Transactional</code> will do it and make that method a transaction boundary.</p> <p>Replace the content of the <code>HeroResource.java</code> by the following one. It contains the new methods for accessing data:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.logging.Log;\nimport io.smallrye.common.annotation.RunOnVirtualThread;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.eclipse.microprofile.openapi.annotations.media.Content;\nimport org.eclipse.microprofile.openapi.annotations.media.Schema;\nimport org.eclipse.microprofile.openapi.annotations.responses.APIResponse;\nimport org.eclipse.microprofile.openapi.annotations.Operation;\nimport org.jboss.resteasy.reactive.RestResponse;\n\n\n\nimport java.net.URI;\nimport java.util.List;\n\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\n\n@Path(\"/api/heroes\")\n@RunOnVirtualThread\npublic class HeroResource {\n\n    @GET\n    @Path(\"/hello\")\n    public String hello() {\n        return \"Hello from Quarkus REST\";\n    }\n\n    @GET\n    @Path(\"/random\")\n    public RestResponse&lt;Hero&gt; getRandomHero() {\n        var hero = Hero.findRandom();\n        if (hero != null) {\n            Log.debugf(\"Found random hero: %s\", hero);\n            return RestResponse.ok(hero);\n        } else {\n            Log.debug(\"No random hero found\");\n            return RestResponse.notFound();\n        }\n    }\n\n    @GET\n    public List&lt;Hero&gt; getAllHeroes() {\n        return Hero.listAll();\n    }\n\n    @GET\n    @Path(\"/{id}\")\n    public RestResponse&lt;Hero&gt; getHero(Long id) {\n        var hero = Hero.&lt;Hero&gt;findById(id);\n        if (hero != null) {\n            return RestResponse.ok(hero);\n        } else {\n            Log.debugf(\"No Hero found with id %d\", id);\n            return RestResponse.notFound();\n        }\n    }\n\n    @POST\n    @Transactional\n    public RestResponse&lt;URI&gt; createHero(@Valid Hero hero, @Context UriInfo uriInfo) {\n        hero.persist();\n        UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(hero.id));\n        Log.debugf(\"New Hero created with URI %s\", builder.build().toString());\n        return RestResponse.created(builder.build());\n    }\n\n    @PUT\n    @Transactional\n    public Hero updateHero(@Valid Hero hero) {\n        Hero retrieved = Hero.findById(hero.id);\n        retrieved.name = hero.name;\n        retrieved.otherName = hero.otherName;\n        retrieved.level = hero.level;\n        retrieved.picture = hero.picture;\n        retrieved.powers = hero.powers;\n        Log.debugf(\"Hero updated with new valued %s\", retrieved);\n        return retrieved;\n    }\n\n    @DELETE\n    @Path(\"/{id}\")\n    @Transactional\n    public RestResponse&lt;Void&gt; deleteHero(Long id) {\n        if (Hero.deleteById(id)) {\n            Log.debugf(\"Hero deleted with %d\", id);\n        }\n        return RestResponse.noContent();\n    }\n}\n</code></pre> <p>Notice that both methods that persist and update a hero, pass a <code>Hero</code> object as a parameter. Thanks to the Bean Validation\u2019s <code>@Valid</code> annotation, the <code>Hero</code> object will be checked to see if it\u2019s valid or not. It it\u2019s not, the transaction will be rollback-ed.</p> <p>If you didn\u2019t yet, open a Terminal and start the application in dev mode:</p> <p><pre><code>./mvnw quarkus:dev\n</code></pre> or</p> <pre><code>$ quarkus dev\n</code></pre> <p>Then, in a new terminal: <pre><code>curl http://localhost:8080/api/heroes\n</code></pre> You should see lots of heroes\u2026</p>"},{"location":"transactions-orm/#crud-tests-in-heroresourcetest","title":"CRUD Tests in HeroResourceTest","text":"<p>We added a few methods to the HeroResource, we should test them!</p> <p>For testing the new methods added to the HeroResource, replace the content of the <code>HeroResourceTest.java</code> by the following:</p> <pre><code>package io.quarkus.workshop.hero;\n\nimport io.quarkus.test.junit.QuarkusTest;\nimport io.restassured.common.mapper.TypeRef;\nimport org.hamcrest.core.Is;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Order;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport static io.restassured.RestAssured.get;\nimport static io.restassured.RestAssured.given;\nimport static jakarta.ws.rs.core.HttpHeaders.ACCEPT;\nimport static jakarta.ws.rs.core.HttpHeaders.CONTENT_TYPE;\nimport static jakarta.ws.rs.core.MediaType.APPLICATION_JSON;\nimport static jakarta.ws.rs.core.Response.Status.BAD_REQUEST;\nimport static jakarta.ws.rs.core.Response.Status.CREATED;\nimport static jakarta.ws.rs.core.Response.Status.NOT_FOUND;\nimport static jakarta.ws.rs.core.Response.Status.NO_CONTENT;\nimport static jakarta.ws.rs.core.Response.Status.OK;\nimport static org.hamcrest.Matchers.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n@QuarkusTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass HeroResourceTest {\n\n    @Test\n    public void testHelloEndpoint() {\n        given()\n                .when()\n                .get(\"/api/heroes/hello\")\n                .then()\n                .statusCode(200)\n                .body(is(\"Hello from Quarkus REST\"));\n    }\n\n    private static final String JSON = \"application/json;charset=UTF-8\";\n\n    private static final String DEFAULT_NAME = \"Super Baguette\";\n    private static final String UPDATED_NAME = \"Super Baguette (updated)\";\n    private static final String DEFAULT_OTHER_NAME = \"Super Baguette Tradition\";\n    private static final String UPDATED_OTHER_NAME = \"Super Baguette Tradition (updated)\";\n    private static final String DEFAULT_PICTURE = \"super_baguette.png\";\n    private static final String UPDATED_PICTURE = \"super_baguette_updated.png\";\n    private static final String DEFAULT_POWERS = \"eats baguette really quickly\";\n    private static final String UPDATED_POWERS = \"eats baguette really quickly (updated)\";\n    private static final int DEFAULT_LEVEL = 42;\n    private static final int UPDATED_LEVEL = 43;\n\n    private static final int NB_HEROES = 500;\n    private static String heroId;\n\n\n    @Test\n    void shouldNotGetUnknownHero() {\n        Long randomId = new Random().nextLong();\n        given()\n                .pathParam(\"id\", randomId)\n                .when()\n                .get(\"/api/heroes/{id}\")\n                .then()\n                .statusCode(NOT_FOUND.getStatusCode());\n    }\n\n    @Test\n    void shouldGetRandomHero() {\n        given()\n                .when()\n                .get(\"/api/heroes/random\")\n                .then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON);\n    }\n\n    @Test\n    void shouldNotAddInvalidItem() {\n        Hero hero = new Hero();\n        hero.name = null;\n        hero.otherName = DEFAULT_OTHER_NAME;\n        hero.picture = DEFAULT_PICTURE;\n        hero.powers = DEFAULT_POWERS;\n        hero.level = 0;\n\n        given()\n                .body(hero)\n                .header(CONTENT_TYPE, APPLICATION_JSON)\n                .header(ACCEPT, APPLICATION_JSON)\n                .when()\n                .post(\"/api/heroes\")\n                .then()\n                .statusCode(BAD_REQUEST.getStatusCode());\n    }\n\n    @Test\n    @Order(1)\n    void shouldGetInitialItems() {\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES, heroes.size());\n    }\n\n    @Test\n    @Order(2)\n    void shouldAddAnItem() {\n        Hero hero = new Hero();\n        hero.name = DEFAULT_NAME;\n        hero.otherName = DEFAULT_OTHER_NAME;\n        hero.picture = DEFAULT_PICTURE;\n        hero.powers = DEFAULT_POWERS;\n        hero.level = DEFAULT_LEVEL;\n\n        String location = given()\n                .body(hero)\n                .header(CONTENT_TYPE, APPLICATION_JSON)\n                .header(ACCEPT, APPLICATION_JSON)\n                .when()\n                .post(\"/api/heroes\")\n                .then()\n                .statusCode(CREATED.getStatusCode())\n                .extract()\n                .header(\"Location\");\n        assertTrue(location.contains(\"/api/heroes\"));\n\n        // Stores the id\n        String[] segments = location.split(\"/\");\n        heroId = segments[segments.length - 1];\n        assertNotNull(heroId);\n\n        given()\n                .pathParam(\"id\", heroId)\n                .when()\n                .get(\"/api/heroes/{id}\")\n                .then()\n                .statusCode(OK.getStatusCode())\n                .body(\"name\", Is.is(DEFAULT_NAME))\n                .body(\"otherName\", Is.is(DEFAULT_OTHER_NAME))\n                .body(\"level\", Is.is(DEFAULT_LEVEL))\n                .body(\"picture\", Is.is(DEFAULT_PICTURE))\n                .body(\"powers\", Is.is(DEFAULT_POWERS));\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES + 1, heroes.size());\n    }\n\n    @Test\n    @Order(3)\n    void shouldUpdateAnItem() {\n        Hero hero = new Hero();\n        hero.id = Long.valueOf(heroId);\n        hero.name = UPDATED_NAME;\n        hero.otherName = UPDATED_OTHER_NAME;\n        hero.picture = UPDATED_PICTURE;\n        hero.powers = UPDATED_POWERS;\n        hero.level = UPDATED_LEVEL;\n\n        given()\n                .body(hero)\n                .header(CONTENT_TYPE, APPLICATION_JSON)\n                .header(ACCEPT, APPLICATION_JSON)\n                .when()\n                .put(\"/api/heroes\")\n                .then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .body(\"name\", Is.is(UPDATED_NAME))\n                .body(\"otherName\", Is.is(UPDATED_OTHER_NAME))\n                .body(\"level\", Is.is(UPDATED_LEVEL))\n                .body(\"picture\", Is.is(UPDATED_PICTURE))\n                .body(\"powers\", Is.is(UPDATED_POWERS));\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES + 1, heroes.size());\n    }\n\n    @Test\n    @Order(4)\n    void shouldRemoveAnItem() {\n        given()\n                .pathParam(\"id\", heroId)\n                .when()\n                .delete(\"/api/heroes/{id}\")\n                .then()\n                .statusCode(NO_CONTENT.getStatusCode());\n\n        List&lt;Hero&gt; heroes = get(\"/api/heroes\").then()\n                .statusCode(OK.getStatusCode())\n                .contentType(APPLICATION_JSON)\n                .extract()\n                .body()\n                .as(getHeroTypeRef());\n        assertEquals(NB_HEROES, heroes.size());\n    }\n\n    private TypeRef&lt;List&lt;Hero&gt;&gt; getHeroTypeRef() {\n        return new TypeRef&lt;List&lt;Hero&gt;&gt;() {\n            // Kept empty on purpose\n        };\n    }\n\n}\n</code></pre> <p>The following test methods have been added to the <code>HeroResourceTest</code> class:</p> <ul> <li><code>shouldNotGetUnknownHero</code>: giving a random Hero identifier, the <code>HeroResource</code> endpoint should return a 204 (No content)</li> <li><code>shouldGetRandomHero</code>: checks that the <code>HeroResource</code> endpoint returns a random hero</li> <li><code>shouldNotAddInvalidItem</code>: passing an invalid <code>Hero</code> should fail when creating it (thanks to the <code>@Valid</code> annotation)</li> <li><code>shouldGetInitialItems</code>: checks that the <code>HeroResource</code> endpoint returns the list of heroes</li> <li><code>shouldAddAnItem</code>: checks that the <code>HeroResource</code> endpoint creates a valid <code>Hero</code></li> <li><code>shouldUpdateAnItem</code>: checks that the <code>HeroResource</code> endpoint updates a newly created <code>Hero</code></li> <li><code>shouldRemoveAnItem</code>: checks that the <code>HeroResource</code> endpoint deletes a hero from the database</li> </ul> <p>Press <code>r</code> in the terminal you have Quarkus dev running. Tests will start running and they should pass.</p>"},{"location":"transactions-orm/#configuring-the-datasource-for-production","title":"Configuring the Datasource for Production","text":"<p>Production databases need to be configured as normal.  So if you want to include a production database config in your <code>application.properties</code> and continue to use Dev Services, we recommend that you use the <code>%prod</code> profile to define your database settings.</p> <p>Just add the following datasource configuration in the <code>src/main/resources/application.properties</code> file:</p> <pre><code>%prod.quarkus.datasource.db-kind=postgresql\n%prod.quarkus.datasource.username=${POSTGRESQL_USERNAME}\n%prod.quarkus.datasource.password=${POSTGRESQL_USERNAME}\n%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://hero-database:5432/${POSTGRESQL_DATABASE}\n%prod.quarkus.hibernate-orm.sql-load-script=import.sql\n%prod.quarkus.hibernate-orm.database.generation=drop-and-create\n</code></pre>"},{"location":"trusted-apps/","title":"Red Hat Trusted Application Pipelines","text":"<p>Red Hat Trusted Application Pipelines is a set of Red Hat products able to build secured pipelines by signing and verify your build artifacts.</p>"},{"location":"trusted-apps/#advanced-cluster-security-acs","title":"Advanced Cluster Security (ACS)","text":"<p>Back to the pipeline itself and let\u2019s look at the 3 Advanced Cluster Security tasks leveraging roxctl</p> <p>The bottom-most task is performing CVE scanning via roxctl image scan.</p> <p>The middle task is performing a policy check via roxctl image check. These policies might be things like \u2018No log4j allowed\u2019 or perhaps no curl, wget nor a package manager in a production image.</p> <p>The top-most task is perform yaml scanning via roxctl deployment check and it might identify that your Deployment.yaml has not properly configured its resource request and limit.</p> <p>A series of dashboards visualize the reporting from these 3 roxctl tasks, click on the View Output icon under ACTIONS</p> <p> </p> <p>These 3 aspects of roxctl are a great example of the \u201cshift-left\u201d idea by bringing these critical checks into the pipeline itself to be executed on each <code>git push</code>.</p>"},{"location":"trusted-apps/#scan-export-sbom","title":"scan-export-sbom","text":"<p>Pushes the SBOM to a CycloneDX repository. Currently, the SBOM is stored in Quay and is not in an easily accessible or readable format. Pushing the SBOM to an additional repository allows us to access the raw JSON/XML file for further use outside of the CI process.</p> <p>The SBOM is an artifact that deserves special mention. Think of the Software Bill of Materials as the ingredient list. I am sure you have gone to the grocery store and picked up an item and reviewed its packaging. On the back of the product there will be a list of ingredients. You can find out that something you might wish to eat includes gluten, perhaps too much sugar, or shellfish (my sister is allergic to shellfish) or perhaps nuts. Well, if you are allergic to nuts you might also be allergic to struts :-) You might remember that infamous Struts 2 vulnerability that allowed 143 million American\u2019s private data to end up on the dark web Struts 2 hack.</p> <p>The SBOM is either a JSON or XML file and is stored in the container registry as the ingredient list associated with the container image.</p>"},{"location":"villain-microservice/","title":"Creating the Villain Microservice","text":"<p>New microservice, new project!  In this section we will see the counterpart of the Hero microservice: the Villain microservice. The Villain REST Endpoint is really similar to the Hero Endpoint but has been developed using the Spring compatibility layer provided by Quarkus. While users are encouraged to use Quarkus extensions, this compatibility layer is provided to make developing new applications with Quarkus a natural getting started experience.</p>"},{"location":"villain-microservice/#bootstrapping-the-villain-rest-endpoint","title":"Bootstrapping the Villain Rest Endpoint","text":"<p>The code is now fully available and you will not have to write any of this microservice. Like we did for hero-service, we will create the villain-service from a Red Hat Developer Hub template, which will automatically pull the complete code from the GitHub repository.</p> <p>So, please proceed with following steps</p> <ul> <li>Navigate to the Create Option: in the left-hand menu of the RHDH, click on the \u201cCreate\u201d option.</li> </ul> <p></p> <ul> <li>Select the template: you\u2019ll see a list of available templates. Choose the <code>OpenCodeQuest - Quarkus microservice with Spring MVC and Spring Data</code> template from the list.</li> </ul> <p></p> <ul> <li> <p>Select your cluster name, check the reference in the current url. The rest of the fields will be pre-filled by default.</p> </li> <li> <p>Click Next button until a summary is shown</p> </li> </ul> <p></p> <ul> <li> <p>Review the configuration. Then, click on <code>Create</code>.</p> </li> <li> <p>If everything went well, you should see the following successful page. Click on the <code>Open Component in Catalog</code>:</p> </li> </ul> <p></p> <ul> <li>Once in the villain-service component home page, you can launch the Dev Spaces opening by clicking the link OpenShift Dev Spaces (VS Code)</li> </ul> <p></p>"},{"location":"villain-microservice/#the-villain-service","title":"The Villain Service","text":"<p>At the heart of the Super Hero application come also  villains.</p> <p>We need to expose a REST API allowing CRUD operations on super heroes. This microservice is also a classical microservice. It uses HTTP to expose a REST API, and it internally stores data into a database.</p> <p>This service will be used by the fight microservice.</p> <p>The code is fully provided. You will not have to write any of this microservice.</p>"},{"location":"villain-microservice/#directory-structure","title":"Directory Structure","text":"<p>Once you bootstrap the project, you get the following directory structure with a few Java classes and other artifacts:</p> <p></p> <p>You get the following in the <code>villain-service</code> folder:</p> <ul> <li>the Maven structure with a <code>pom.xml</code></li> <li>an <code>io.quarkus.workshop.villain.VillainController</code> controller exposed on <code>/api/heroes</code></li> <li>an associated unit test <code>VillainControllerTest</code></li> <li>example <code>Dockerfile</code> files for both native and jvm modes in <code>src/main/docker</code></li> <li>the <code>application.properties</code> configuration file</li> </ul> <p>Look at the <code>pom.xml</code>.</p> <p>The <code>pom.xml</code> is basically the same than for heroes apart that it contains a few more dependencies: <code>quarkus-spring-web</code> and <code>quarkus-spring-data</code>.</p> <p>The Quarkus Spring compatibility extensions map Spring APIs to APIs in existing extensions that have already been optimized for fast startup, reduced memory utilization and native compilation, like RestEasy and CDI.</p> <p>Be aware that Quarkus Spring compatibility extensions do not utilize the Spring application context. For this reason, attempting to utilize additional Spring libraries will likely not work.</p>"},{"location":"villain-microservice/#the-controller","title":"The Controller","text":"<p>We get a rest controller, the <code>VillainController.java</code> with the following content:</p> <pre><code>package io.quarkus.workshop.villain;\n\nimport io.quarkus.logging.Log;\nimport io.smallrye.common.annotation.RunOnVirtualThread;\nimport jakarta.transaction.Transactional;\nimport jakarta.validation.Valid;\nimport jakarta.ws.rs.core.Context;\nimport jakarta.ws.rs.core.UriBuilder;\nimport jakarta.ws.rs.core.UriInfo;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.DeleteMapping;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.server.ResponseStatusException;\n\nimport java.net.URI;\nimport java.util.List;\n\n@RunOnVirtualThread\n@RestController\n@RequestMapping(value = \"/api/villains\")\npublic class VillainController {\n\n\n    private final VillainRepository repository;\n\n    public VillainController(VillainRepository repository) {\n        this.repository = repository;\n    }\n\n    @GetMapping(\"/random\")\n    public ResponseEntity&lt;Villain&gt; getRandomVillain() {\n        var villain = repository.findRandom();\n        if (villain != null) {\n            Log.debugf(\"Found random villain: %s\", villain);\n            return ResponseEntity.ok(villain);\n        } else {\n            Log.debug(\"No random villain found\");\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @GetMapping\n    public List&lt;Villain&gt; getAllVillains() {\n        return repository.findAll();\n    }\n\n    @GetMapping(\"/{id}\")\n    public ResponseEntity&lt;Villain&gt; getVillain(Long id) {\n        var villain = repository.findById(id).orElse(null);\n        if (villain != null) {\n            return ResponseEntity.ok(villain);\n        } else {\n            Log.debugf(\"No Villain found with id %d\", id);\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @PostMapping\n    @Transactional\n    public ResponseEntity&lt;URI&gt; createVillain(@Valid Villain villain, @Context UriInfo uriInfo) {\n        var persisted = repository.save(villain);\n        UriBuilder builder = uriInfo.getAbsolutePathBuilder().path(Long.toString(persisted.getId()));\n        Log.debugf(\"New Villain created with URI %s\", builder.build().toString());\n        return ResponseEntity.created(builder.build()).build();\n    }\n\n    @PutMapping\n    @Transactional\n    public Villain updateVillain(@Valid Villain villain) {\n        Villain retrieved = repository.findById(villain.getId()).orElseThrow(\n                () -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND, \"Villain not found\"));\n        retrieved.setName(villain.getName());\n        retrieved.setOtherName(villain.getOtherName());\n        retrieved.setLevel(villain.getLevel());\n        retrieved.setPicture(villain.getPicture());\n        retrieved.setPowers(villain.setPowers());\n        Log.debugf(\"Villain updated with new valued %s\", retrieved);\n        return retrieved;\n    }\n\n    @DeleteMapping(\"/{id}\")\n    @Transactional\n    public ResponseEntity&lt;Void&gt; deleteVillain(Long id) {\n        repository.deleteById(id);\n        return ResponseEntity.noContent().build();\n    }\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello Villain Service\";\n    }\n}\n</code></pre> <p>This controller exposes CRUD operations to \u201cvillains\u201d and leverages Spring Web and Spring Data JPA annotations for handling HTTP requests and transactions:</p> <ol> <li> <p>@RestController: Marks the class as a RESTful controller where every method returns a JSON response instead of a view. </p> </li> <li> <p>@RequestMapping: Specifies the base URL path (<code>/api/villains</code>) for all the endpoints within this controller. It replaces the standard JAX-RS <code>@Path</code></p> </li> <li> <p>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping: These annotations define HTTP methods (GET, POST, PUT, DELETE) to map specific endpoints to CRUD operations.</p> </li> </ol> <p>Not Spring specific annotations but used like in the hero-service:</p> <ol> <li> <p>@Transactional: Ensures that the methods annotated with it are executed within a transaction context, which automatically commits or rolls back the transaction.</p> </li> <li> <p>@Valid: Validates the input entity (<code>Villain</code>) based on the constraints defined on its fields.</p> </li> <li> <p>@Context: Injects <code>UriInfo</code>, which provides contextual information about the current URI to help in creating new URIs for created resources.</p> </li> <li> <p>@RunOnVirtualThread: Runs the controller on a virtual thread for better concurrency management. This is specific to the SmallRye library.</p> </li> </ol>"},{"location":"villain-microservice/#accessing-database","title":"Accessing Database","text":"<p>As everything is in place the <code>import.sql</code> file contains already all SQL statements to populate the villain database.</p>"},{"location":"villain-microservice/#the-villain-repository","title":"The Villain repository","text":"<p>As we are following a Spring Data programming model with JPA,we need to extend the JPA specific Repository interface, JpaRepository.  This will enable Quarkus to find this interface and automatically create an implementation for it. By extending the interface, we get the most relevant CRUD methods automatically. </p> <p>You can check the <code>VillainRepository.java</code> code. It also contains a more specific method to retrieve a villain randomly from database:</p> <pre><code>default Villain findRandom() {\n    var count = count();\n    var index = (int) (Math.random() * count);\n    return findAll().get(index);\n}\n</code></pre>"},{"location":"villain-microservice/#the-villain-entity","title":"The Villain entity","text":"<p>Finally we have an entity class representing the villains.</p> <pre><code>package io.quarkus.workshop.villain;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\nimport jakarta.validation.constraints.Size;\n\n\n@Entity\npublic class Villain {\n\n    @Id\n    @SequenceGenerator(name = \"villainSequence\", sequenceName = \"villain_seq\", allocationSize = 1, initialValue = 10)\n    @GeneratedValue(generator = \"villainSequence\")\n    private Long id;\n\n    private String name;\n\n    private String otherName;\n\n\n    private int level;\n    private String picture;\n\n    @Column(columnDefinition = \"TEXT\")\n    public String powers;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public @NotNull @Size(min = 3, max = 50) String getName() {\n        return name;\n    }\n\n    public void setName(@NotNull @Size(min = 3, max = 50) String name) {\n        this.name = name;\n    }\n\n    public String getOtherName() {\n        return otherName;\n    }\n\n    public void setOtherName(String otherName) {\n        this.otherName = otherName;\n    }\n\n    @NotNull\n    @Min(1)\n    public int getLevel() {\n        return level;\n    }\n\n    public void setLevel(@NotNull @Min(1) int level) {\n        this.level = level;\n    }\n\n    public String getPicture() {\n        return picture;\n    }\n\n    public void setPicture(String picture) {\n        this.picture = picture;\n    }\n\n    public String setPowers() {\n        return powers;\n    }\n\n    public void setPowers(String powers) {\n        this.powers = powers;\n    }\n}\n</code></pre>"},{"location":"villain-microservice/#tests","title":"Tests","text":"<p>As in the case of the heroes, the tests could not be missing here.  A test class is provided and contains the basic tests to ensure that the villain microservice works correctly.</p> <p>You can check that everything works fine by starting the application in development mode.</p> <p>run one of the following commands:</p> <p><code>./mvnw quarkus:dev</code></p> <p>or</p> <p><code>quarkus dev</code></p> <p>Note that the tests have been successful run. </p> <p>Also, you can curl the villains endopoint and you should get lots of villains</p> <pre><code>curl http://localhost:8080/api/villains\n</code></pre>"},{"location":"villain-microservice/#deploy-the-villain-microservice","title":"Deploy the Villain microservice","text":"<p>To deploy the Villain service, remember to perform a commit&amp;push of the code (there is already a change on <code>application.properties</code> waiting to be pushed). </p> <p>You can get some help here</p>"},{"location":"villain-microservice/#houston-weve-got-a-problem","title":"Houston, we\u2019ve got a problem","text":"<p>At this stage, you should observe an issue during the CI pipeline. The step acs-image-check (responsible of verifying that we are not violating any policies in our cluster) is now failing.</p> <p></p> <p>Click the task to get the logs and understand what policy has been violated</p> <p></p> <p>As you can see, it looks like a SuperVillain  has introduced a bad dependency in our code ! </p> <p>Open the <code>pom.xml</code> file in DevSpaces IDE</p> <p></p> <p>Thanks to the Red Hat Dependency Analytics IDE extension, you can even see that the dependency is automatically underlined suggesting there\u2019s an issue with it.</p> <p>Remove the dependency as it\u2019s not needed in our code</p>"},{"location":"villain-microservice/#deploy-the-villain-microservice-after-fixing-the-issue","title":"Deploy the Villain microservice after fixing the issue","text":"<p>Once you have corrected the dependency issue and comited your code, you can tag and release your code in GitLab to promote in preprod and prod.</p>"},{"location":"villain-microservice/#stop-your-devspaces-workspace","title":"Stop your DevSpaces Workspace","text":"<p>As you now have fully deployed your microservice, you do not need anymore the DevSpaces workspace so let\u2019s just stop it to preserve resources.</p> <p>Click the grey button \u201d&gt;&lt;\u201d on the bottom left of DevSpaces IDE</p> <p></p> <p>Then Click \u201cDev Spaces : Stop Workspace</p> <p></p>"},{"location":"web-application/","title":"User Interface","text":"<p>The first thing we are going to do to familiarise ourselves with the framework and tools such as Red Hat Developer Hub and Dev Spaces is to create the UI.</p>"},{"location":"web-application/#the-web-application","title":"The Web Application","text":"<p>This application exposes the user interface to make the fight.</p> <p>The user interface is written in JavaScript using React, and the compiled assets are exposed from a Quarkus microservice.</p> <p>The application also performs some service composition logic, as it makes HTTP client requests to the heroes, villains and fight services:</p> <p></p>"},{"location":"web-application/#bootstrapping-the-web-application-endpoint","title":"Bootstrapping the Web Application Endpoint","text":"<p>Once logged in the Red Hat Developer Hub, please proceed with following steps:</p> <ul> <li>Navigate to the Create Option: in the left-hand menu of the RHDH, click on the \u201cCreate\u201d option.</li> </ul> <p></p> <ul> <li>Select the template: you\u2019ll see a list of available templates. Choose the <code>OpenCodeQuest - Fight-UI service</code> template from the list which will automatically pull the complete code from the GitHub repository.</li> </ul> <p></p> <ul> <li>Select your cluster name, check the reference in the current url. The rest of the fields will be pre-filled by default.</li> </ul> <p></p> <ul> <li>Click Next button until a summary is shown</li> </ul> <p></p> <ul> <li> <p>Review the configuration. Then, click on <code>Create</code>.</p> </li> <li> <p>If everything went well, you should see the following successful page. Click on the <code>Open Component in Catalog</code>:</p> </li> </ul> <p></p> <ul> <li>== The ui-fight component home page is shown==</li> </ul> <p></p> <ul> <li> <p> Entities not found warning </p> <p>The warning you\u2019re seeing is expected because the web application relies on several microservices\u2014Hero, Villain, and Fight\u2014which haven\u2019t been deployed yet.Once the entire system is up and running, the message will no longer appear.</p> </li> </ul> <p>Go to the Topology tab</p> <p></p> <p>Here you can find the three ui-fight instances deployed in the three environments available: dev, preprod and production.</p> <p>Click in the little arrow symbol that allows you to navigate to the ui url in a browser.</p> <p>You should see something like:</p> <p></p> <p>Again, the errors you see are due to the absence of the backend microservices.</p> <p>Once they will be in place, you will see something like:</p> <p></p>"}]}